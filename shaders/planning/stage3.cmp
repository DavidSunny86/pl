

void getDonorPositionAndNormal( inout vec3 position, inout vec3 normal, inout vec3 xAxis, in uint donorGridIndex, in uint graftIndex, in uint rotationAngleIndex )
{
    // get defect graft data
    vec3 defectSurfaceNormal = defectSolutionSurfaceNormals( graftIndex );    
    vec3 defectGraftNormal   = defectSolutionGraftNormals  ( graftIndex );   
    vec3 defectGraftX        = cross( defectGraftNormal, vec3( 0, 0, 1 ) );
    
    // if so, check if location is valid with existing selection
    uint site, localIndex;
    getDonorSiteAndIndex( site, localIndex, donorGridIndex );

    // get donor surface normal, it is used to find rotation from defect to donor
    vec3 donorSurfaceNormal = donorSiteNormals ( site, localIndex ).xyz;
    
    // get rotation from defect to donor for this rotation angle
    mat4 rotation;  defectToDonorRotation( rotation, defectSurfaceNormal, donorSurfaceNormal, getRotationAngle( rotationAngleIndex ) );

    normal   = normalize( ( rotation * vec4( defectGraftNormal, 1.0 ) ).xyz );
    position = donorSitePositions ( site, localIndex ).xyz;
    xAxis    = normalize( ( rotation * vec4( defectGraftX, 1.0 ) ).xyz );
}


bool isSelectionValid( in vec3 candidateGraftPosition, in vec3 candidateGraftNormal, in float candidateGraftRadius, in uint shuffledGraftIndices[PL_MAX_GRAFTS_PER_SOLUTION], in uint solutionCount )  
{
    bool result = true;
    
    // check against all grafts in current solution
    for ( uint i=0; i < solutionCount; i++ )
    {
        float existingGraftRadius   = defectSolutionGraftRadii ( shuffledGraftIndices[i] );
        vec3  existingGraftPosition = getDonorSolutionPositions( shuffledGraftIndices[i] );
        vec3  existingGraftNormal   = getDonorSolutionNormals  ( shuffledGraftIndices[i] );

        if ( cylinderOverlap( candidateGraftPosition, candidateGraftNormal, candidateGraftRadius, 
                              existingGraftPosition,  existingGraftNormal,  existingGraftRadius ) > 0.0 )
        {
            // overlap, reject
            result = false;
            break;        
        }
    }

    // check if new graft intersects defect solution ( possible if donor area is close to defect spline )
    for ( uint i=0; i < uDefectSolutionGraftCount; i++ )
    {
        float existingGraftRadius   = defectSolutionGraftRadii     ( i );
        vec3  existingGraftPosition = defectSolutionGraftPositions ( i );
        vec3  existingGraftNormal   = defectSolutionGraftNormals   ( i );

        if ( cylinderOverlap( candidateGraftPosition, candidateGraftNormal, candidateGraftRadius, 
                              existingGraftPosition,  existingGraftNormal,  existingGraftRadius ) > 0.0 )
        {
            // overlap, reject
            result = false;
            break;        
        }
    }

    return result;
} 


bool getBestMatchForGraft( inout float lowestRMS, in uint shuffledGraftIndices[ PL_MAX_GRAFTS_PER_SOLUTION ], in uint currentSolutionCount )
{
    // index of current graft
    uint graftIndex = shuffledGraftIndices[ currentSolutionCount ];

    // store current lowest data
    bool  lowestFound         = false;
    vec3  lowestDonorPosition = vec3( -1.0, -1.0, -1.0 );
    vec3  lowestDonorNormal   = vec3( -1.0, -1.0, -1.0 );
    vec3  lowestDonorXAxis    = vec3( -1.0, -1.0, -1.0 );
    
    // for each grid point
    for ( uint i=0; i < uDonorTotalGridPointCount; i++ )
    {     
        // for each direction
        for ( uint j=0; j < PL_NUM_COMPARISION_DIRECTIONS; j++ )
        {     
            // get the rms for this point and direction
            float currentRMS = getRMS( j, i, graftIndex );

            // check if this location results in a better RMS
            if ( currentRMS > 0.0 && currentRMS < lowestRMS )
            {         
                // get candidate donor graft data
                float candidateGraftRadius = defectSolutionGraftRadii( graftIndex );   
                vec3 candidateGraftPosition, candidateGraftNormal, candidateXAxis;
                getDonorPositionAndNormal( candidateGraftPosition, candidateGraftNormal, candidateXAxis, i, graftIndex, j );
                
                // make sure this is valid with current solution
                if ( isSelectionValid( candidateGraftPosition, candidateGraftNormal, candidateGraftRadius, shuffledGraftIndices, currentSolutionCount ) )
                {   
                    lowestFound = true;
                    lowestRMS   = currentRMS;                  
                    lowestDonorPosition = candidateGraftPosition;                            
                    lowestDonorNormal   = candidateGraftNormal;
                    lowestDonorXAxis    = candidateXAxis;
                }                
            }
    
        }      
    }
    
    if ( lowestFound )
    {
        setDonorSolutionPositions( lowestDonorPosition, graftIndex );
        setDonorSolutionNormals  ( lowestDonorNormal,   graftIndex );
        setDonorSolutionXAxes    ( lowestDonorXAxis,    graftIndex );
    }
    
    return lowestFound;

}


void getShuffledIndexArray( inout uint array[ PL_MAX_GRAFTS_PER_SOLUTION ], in uint size, inout uint seed )
{   
    // fill array with incremental indices
    for (uint i=0; i < size; i++)
    {
        array[i] = i;
    }

    // randomize orders
    for (uint i = 0; i < size; i++) 
    {
        uint j = uint( rand( seed ) * float( size ) );
        uint t = array[j];
        array[j] = array[i];
        array[i] = t;
    }    
}


void main(void)
{ 
    // get invocation unique seed value for RNG
    uint seed = generateSeed();

    float totalRMS = 0;

    uint shuffledGraftIndices [ PL_MAX_GRAFTS_PER_SOLUTION ];   // shuffled graft indices        
    getShuffledIndexArray( shuffledGraftIndices, uDefectSolutionGraftCount, seed );

    // for each graft
    for ( uint i=0; i < uDefectSolutionGraftCount; i++ )
    {    
        float lowestRMS = PL_FLT_MAX;
        
        if ( !getBestMatchForGraft( lowestRMS, shuffledGraftIndices, i ) )
        {
            // invalid solution, exit
            totalRMS = -1.0;
            break;
        }
        
        // increment rms total
        totalRMS += lowestRMS;
    }

    // export total rms
    totalRmsOutput[ gl_GlobalInvocationID.x ] = totalRMS;
}

