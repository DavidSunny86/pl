#version 430

#define PL_MAX_GRAFTS_PER_SOLUTION  16
#define PL_MAX_DONOR_SITES          5
#define PL_MAX_CAP_TRIANGLES        2048
#define PL_MAX_GRAFT_RADIUS         4.0

layout (local_size_x = 1024) in;

// input data
layout (std430,  binding = 0) buffer defectSiteDataBlock  { vec4 defectSiteData[]; };
layout (std430,  binding = 1) buffer donorSiteDataBlock   { vec4 donorSiteData[];  };

// output data
layout (std430,  binding = 2) buffer defectCapIndicesBuffer { uint defectCapIndices[]; };
layout (std430,  binding = 3) buffer donorCapIndicesBuffer  { uint donorCapIndices[];  };

// input uniforms
uniform uint  uGraftCount;
uniform vec4  uGraftPositions [PL_MAX_GRAFTS_PER_SOLUTION];
uniform vec4  uGraftNormals   [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint  uDefectSiteMeshSize;

uniform uint  uDonorSiteCount;
uniform uint  uDonorSiteMeshSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSiteGridSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSiteDataOffset [PL_MAX_DONOR_SITES];


struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


triangle defectSiteTriangles( in uint i )
{
    uint j = i*4;    
    triangle t;
    t.p0 = vec3( defectSiteData[j+0] );
    t.p1 = vec3( defectSiteData[j+1] );
    t.p2 = vec3( defectSiteData[j+2] );
    t.n  = vec3( defectSiteData[j+3] );
    return t;
}


void setDefectCapTriangleIndex( in uint graftIndex, in uint i, in uint triIndex )
{
    uint offset = (graftIndex * PL_MAX_CAP_TRIANGLES) + 1; // + 1 triangle count is [0]
    defectCapIndices[ offset+i ] = triIndex;
}


void setDefectCapIndexCount( in uint graftIndex, in uint count )
{
    uint offset = graftIndex * PL_MAX_CAP_TRIANGLES; 
    defectCapIndices[ offset ] = count;
}


uint totalDonorPoints()
{
    uint totalPoints = 0;
    for (uint i=0; i<uDonorSiteCount; i++)
    {
        totalPoints += uDonorSiteGridSize[ i ];   
    }    
        
    return totalPoints;
}


void getDonorSiteAndIndex( inout uint site, inout uint localIndex )
{
    localIndex = gl_GlobalInvocationID.x;
    for (uint i=0; i<uDonorSiteCount; i++)
    {
        if ( localIndex < uDonorSiteGridSize[ i ] )
        {
            site = i;
            break;
        }
        localIndex -= uDonorSiteGridSize[ i ];
    }
}


vec4 donorSitePositions( in uint site, in uint i )
{   
    return donorSiteData[ uDonorSiteDataOffset[ site ] + i ];
}


vec4 donorSiteNormals( in uint site, in uint i )
{
    return donorSiteData[ uDonorSiteDataOffset[ site ] + uDonorSiteGridSize[ site ] + i ];
}


triangle donorSiteTriangles( in uint site, in uint i )
{
    uint j = uDonorSiteDataOffset[ site ] + uDonorSiteGridSize[ site ]*2 + i*4;  
    triangle t;
    t.p0 = vec3( donorSiteData[j+0] );
    t.p1 = vec3( donorSiteData[j+1] );
    t.p2 = vec3( donorSiteData[j+2] );
    t.n  = vec3( donorSiteData[j+3] );
    return t;
}


void setDonorCapTriangleIndex( in uint i, in uint triIndex )
{
    uint offset = (gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES) + 1; // + 1 triangle count is [0]
    donorCapIndices[ offset+i ] = triIndex;
}


void setDonorCapIndexCount( in uint count )
{
    uint offset = (gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES); 
    donorCapIndices[ offset ] = count;
}


vec3 closestPointOnSegment( in vec3 p, in vec3 a, in vec3 b)
{
    vec3 ab = b - a;
    float t = dot( (p - a), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return a + (t * ab);
}


float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return distance( v, dot( v, axis )*axis );
}


bool intersectTriangle( in vec3 position, in vec3 normal, in triangle t, in float radius ) 
{
    if ( dot( t.n, normal ) < 0 )
        return false;

    // get vector from graft centre to triangle point
    vec3 point0 = t.p0 - position;
    vec3 point1 = t.p1 - position;
    vec3 point2 = t.p2 - position;
    
    return ( distToAxis( normal, point0 ) < radius ||   // check vertices first
             distToAxis( normal, point1 ) < radius ||
             distToAxis( normal, point2 ) < radius ||
             distance( closestPointOnSegment( position, t.p0, t.p1 ), position ) < radius ||    // check edges after (in case no vertex is inside)
             distance( closestPointOnSegment( position, t.p1, t.p2 ), position ) < radius ||
             distance( closestPointOnSegment( position, t.p2, t.p0 ), position ) < radius );
}


uint calculateDefectCap( in vec3 position, in vec3 normal, in uint index, in float radius )
{ 
    uint triangleCount = 0;
    
    for(uint i=0; i<uDefectSiteMeshSize; i++)
    {
        // create triangle struct
        triangle tri = defectSiteTriangles( i );

        if ( intersectTriangle( position, normal, tri, radius ) )
        {
            // if intersected by graft cap, add to temp array
            setDefectCapTriangleIndex( index, triangleCount, i );
            triangleCount++;
        }
    }
    return triangleCount;
}


uint calculateDonorCap( in vec3 position, in vec3 normal, in uint site, in float radius )
{    
    uint triangleCount = 0;
    
    for(uint i=0; i<uDonorSiteMeshSize[ site ]; i++)
    {
        // create triangle struct
        triangle tri = donorSiteTriangles( site, i );

        if ( intersectTriangle( position, normal, tri, radius ) )
        {
            // if intersected by graft cap, add to temp array
            setDonorCapTriangleIndex( triangleCount, i );
            triangleCount++;
        }
    }
    return triangleCount;
}


void main(void)
{ 
    // calc total number of donor points   
    uint totalDonorPoints = totalDonorPoints(); 

    // check if invocation id represents a donor point or defect point 
    if ( gl_GlobalInvocationID.x < totalDonorPoints )
    {
     
        // get specific defect site and local index of grid point
        uint site, localIndex;
        getDonorSiteAndIndex( site, localIndex );
          
        // get grid point
        vec3 gridPosition = vec3( donorSitePositions( site, localIndex ) );
        vec3 gridNormal   = vec3( donorSiteNormals  ( site, localIndex ) );
        
        uint donorCount = calculateDonorCap( gridPosition, gridNormal, site, PL_MAX_GRAFT_RADIUS );   
        setDonorCapIndexCount ( donorCount );
    
    }
    else
    {
    
        uint graftIndex = gl_GlobalInvocationID.x - totalDonorPoints;
        // if above graft count, abort
        if ( graftIndex < uGraftCount )
        {
            vec3 graftPosition = vec3( uGraftPositions[graftIndex] );
            vec3 graftNormal   = vec3( uGraftNormals  [graftIndex] );
            
            uint defectCount = calculateDefectCap( graftPosition, graftNormal, graftIndex, PL_MAX_GRAFT_RADIUS );
            setDefectCapIndexCount ( graftIndex, defectCount );
        }
    
    }
}


