#version 430

#define PL_MAX_GRAFTS_PER_SOLUTION  20
#define PL_MAX_DONOR_SITES          5
#define PL_MAX_CAP_TRIANGLES        500

layout (local_size_x = 16) in;

// input data
layout (std430,  binding = 0) buffer defectSiteDataBlock  { vec4 defectSiteData[]; };
layout (std430,  binding = 1) buffer donorSiteDataBlock   { vec4 donorSiteData[];  };

// temporary data
layout (std430,  binding = 2) buffer tempBuffer0          { vec4 tempDefectTriangles[]; };
layout (std430,  binding = 3) buffer tempBuffer1          { vec4 tempDonorTriangles[];  };

// state output
layout (std430,  binding = 4) buffer rmsOutputBlock       { float rmsOutput[]; };

// input uniforms
uniform uint  uGraftCount;
uniform vec4  uGraftPositions [PL_MAX_GRAFTS_PER_SOLUTION];
uniform vec4  uGraftNormals   [PL_MAX_GRAFTS_PER_SOLUTION];
uniform float uGraftRadii     [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint  uDefectSiteMeshSize;

uniform uint  uDonorSiteCount;
uniform uint  uDonorSiteMeshSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSiteGridSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSitePerimSize  [PL_MAX_DONOR_SITES];


struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct edge
{
    vec3 p0;
    vec3 p1;
    vec3 n;
};


triangle defectSiteTriangles( in uint i )
{
    uint j = i*4;    
    triangle t;
    t.p0 = vec3( defectSiteData[j+0] );
    t.p1 = vec3( defectSiteData[j+1] );
    t.p2 = vec3( defectSiteData[j+2] );
    t.n  = vec3( defectSiteData[j+3] );
    return t;
}

triangle defectCapTriangles( in uint i )
{
    uint j = i*4;  
    triangle t;
    t.p0 = vec3( gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + tempDefectTriangles[j+0] );
    t.p1 = vec3( gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + tempDefectTriangles[j+1] );
    t.p2 = vec3( gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + tempDefectTriangles[j+2] );
    t.n  = vec3( gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + tempDefectTriangles[j+3] );
    return t;
}


void defectCapTriangles( in uint i, in triangle t )
{
    uint j = i*4;
    tempDefectTriangles[ gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + j+0 ] = vec4( t.p0,  1.0 );
    tempDefectTriangles[ gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + j+1 ] = vec4( t.p1, 1.0 );
    tempDefectTriangles[ gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + j+2 ] = vec4( t.p2, 1.0 );
    tempDefectTriangles[ gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + j+4 ] = vec4( t.n,  1.0 );
}


void getDonorSiteAndIndex( inout uint site, inout uint localIndex )
{
    localIndex = gl_GlobalInvocationID.x;
    for (uint i=0; i< site; i++)
    {
        if ( localIndex < uDonorSiteGridSize[ i ] )
        {
            site = i;
            break;
        }
        localIndex -= uDonorSiteGridSize[ i ];
    }
}


uint getDonorSiteOffset( in uint site )
{
    uint index = 0;
    for (uint i=0; i< site; i++)
    {
        index+= uDonorSiteGridSize[i]*2 + uDonorSiteMeshSize[i]*4 + uDonorSitePerimSize[i]*2;
    }
    return index;
}


vec4 donorSitePositions( in uint site, in uint i )
{   
    return donorSiteData[ getDonorSiteOffset( site ) + i];
}


vec4 donorSiteNormals( in uint site, in uint i )
{
    return donorSiteData[ getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ] + i];
}


triangle donorSiteTriangles( in uint site, in uint i )
{
    uint j = getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ]*2 + i*4;  
    triangle t;
    t.p0 = vec3( donorSiteData[j+0] );
    t.p1 = vec3( donorSiteData[j+1] );
    t.p2 = vec3( donorSiteData[j+2] );
    t.n  = vec3( donorSiteData[j+3] );
    return t;
}


triangle donorCapTriangles( in uint i )
{
    uint j = i*4;  
    triangle t;
    t.p0 = vec3( gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + tempDonorTriangles[j+0] );
    t.p1 = vec3( gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + tempDonorTriangles[j+1] );
    t.p2 = vec3( gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + tempDonorTriangles[j+2] );
    t.n  = vec3( gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + tempDonorTriangles[j+3] );
    return t;
}


void donorCapTriangles( in uint i, in triangle t )
{
    uint j = i*4;
    tempDonorTriangles[ gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + j+0 ] = vec4( t.p0, 1.0 );
    tempDonorTriangles[ gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + j+1 ] = vec4( t.p1, 1.0 ); 
    tempDonorTriangles[ gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + j+2 ] = vec4( t.p2, 1.0 );
    tempDonorTriangles[ gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES + j+3 ] = vec4( t.n,  1.0 );
}


edge donorSiteEdge( in uint site, in uint i )
{
    uint offset = getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ]*2 + uDonorSiteMeshSize[ site ]*4; 

    uint j = offset + i;
    uint k = offset + ( (i+1) % uDonorSitePerimSize[ site ] );
    
    edge e;
    e.p0 = vec3( donorSiteData[ j ] );
    e.p1 = vec3( donorSiteData[ k ] );  
    e.n  = vec3( donorSiteData[ j+uDonorSitePerimSize[ site ] ] );
    return e;
}


uint randomize( inout uint seed )
{   
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}


float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}


vec3 closestPointOnSegment( in vec3 p, in edge e)
{
    vec3 ab = e.p1 - e.p0;
    float t = dot( (p - e.p0), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return e.p0 + t * ab;
}


bool isWithinSite( in uint site, in vec3 pos, in float radius )
{
    bool inside = true;
    for (int i=0; i<uDonorSitePerimSize[ site ]; i++)
    {
        edge e = donorSiteEdge( site, i );
        if ( length( pos - closestPointOnSegment( pos, e) ) < radius )
        {
            inside = false;
        }        
    }    
    return inside;
}


float area( in triangle t)
{
    return 0.5 * length( cross( (t.p1 - t.p0),  (t.p2 - t.p0) ) );
}



float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return length(v - dot(v, axis)*axis);
}


bool intersectTriangle( in vec3 position, in vec3 normal, in triangle t, in float radius ) 
{
    if ( dot(t.n, normal) < 0 )
        return false;

    // get vector from graft centre to triangle point
    vec3 point0 = t.p0 - position;
    vec3 point1 = t.p1 - position;
    vec3 point2 = t.p2 - position;
    
    return ( distToAxis( normal, point0 ) < radius ||
             distToAxis( normal, point1 ) < radius ||
             distToAxis( normal, point2 ) < radius );
  
}


uint calculateDonorCap( in vec3 position, in vec3 normal, in float radius )
{ 
    uint site, localIndex;
    getDonorSiteAndIndex( site, localIndex );
    
    uint triangleCount = 0;
    
    for(uint i=0; i<uDonorSiteMeshSize[ site ]; i++)
    {
        // create triangle struct
        triangle t = donorSiteTriangles( site, i );

        if ( intersectTriangle( position, normal, t, radius ) )
        {
            donorCapTriangles( triangleCount, t );
            triangleCount++;
        }
    }
    return triangleCount;
}


uint calculateDefectCap( in vec3 position, in vec3 normal, in float radius )
{ 
    // get global invocation id

    uint triangleCount = 0;
    
    for(uint i=0; i<uDefectSiteMeshSize; i++)
    {
        // create triangle struct
        triangle t = defectSiteTriangles( i );

        if ( intersectTriangle( position, normal, t, radius ) )
        {
            defectCapTriangles( triangleCount, t );
            triangleCount++;
        }
    }
    return triangleCount;
}


bool rayIntersect( inout vec3 point, inout float t, in vec3 rayStart, in vec3 rayDir, in triangle tri )
{
    // Compute ray/plane intersection
    float dn = rayDir * tri.n;

    if (dn == 0 )
    {      
        return false;   // ray is parallel to plane 
    }

    float dist = dot( tri.p0, tri.n );

    t = (dist - rayStart*tri.n) / dn;
    
    point = rayStart + t * rayDir;

    // Compute barycentric coords
    float totalAreaDiv = 1.0 / dot( cross( tri.p1-tri.p0, tri.p2-tri.p0 ) , tri.n);
    float u = dot( cross( tri.p2-tri.p1, point-tri.p1 ), tri.n) * totalAreaDiv;
    float v = dot( cross( tri.p0-tri.p2, point-tri.p2 ), tri.n) * totalAreaDiv;

    // Reject if outside triangle
    if (u < 0 || v < 0 || u + v > 1)
        return false; 
    
    return true;
}


vec3 rayIntersectDefect( in vec3 rayStart, in vec3 rayDir, in uint count )
{
    vec3 closestPoint;
    float minT;
    for (uint i=0; i<count*4; i+=4)
    {
        triangle tri = defectCapTriangles( i );
        vec3 point;
        float t;
        if ( rayIntersect( point, t, rayStart, rayDir, tri ) )
        { 
            if ( abs( t ) < minT )
            {
                minT = abs( t );
                closestPoint = point;
            }
        }
    }
    return closestPoint;
}



vec3 rayIntersectDonor( in vec3 rayStart, in vec3 rayDir, in uint count )
{
    vec3 closestPoint;
    float minT;
    for (uint i=0; i<count; i++)
    {
        triangle tri = donorCapTriangles( i );
        vec3 point;
        float t;
        if ( rayIntersect( point, t, rayStart, rayDir, tri ) )
        {
            if ( abs( t ) < minT )
            {
                minT = abs( t );
                closestPoint = point;
            }
        }
    }
    return closestPoint;
}


float calcRMS( in uint defectCount, in uint donorCount, in vec3 normal )
{
    vec3 pos[1];
    pos[0] = vec3(0,0,0);
    uint numPoints = 1;
    
    float squaredDistanceSum = 0;
    for (uint i=0; i<numPoints; i++)
    {
        vec3 defectPoint = rayIntersectDefect( pos[i], normal, defectCount );
        vec3 donorPoint  = rayIntersectDonor ( pos[i], normal, donorCount  );
        squaredDistanceSum += distance(defectPoint, donorPoint) * distance(defectPoint, donorPoint);
    }

    return squaredDistanceSum / float( numPoints );
}


void main(void)
{ 
    uint site, localIndex;
    getDonorSiteAndIndex( site, localIndex );
    
    vec3 gridPoint = vec3( donorSitePositions( site, localIndex ) );
    
    // for each graft
    for (uint i=0; i<uGraftCount; i++)
    {
        float rms;
        if ( isWithinSite( site, gridPoint, uGraftRadii[i] ) )
        {
            // calculate defect cap triangles and store in temp buffer
            uint defectCount = calculateDefectCap( vec3( uGraftPositions[i] ), vec3( uGraftNormals[i] ), uGraftRadii[i] );
            // calculate cap triangles and store in temp buffer
            uint donorCount = calculateDonorCap( gridPoint, vec3( uGraftNormals[i] ), uGraftRadii[i] );
            // calculate rms error
            rms = calcRMS( defectCount, donorCount, vec3( uGraftNormals[i] ) );  
        }
        else
        {
            // doesnt fit in boundary
            rms = -1;
        }
        rmsOutput[ gl_GlobalInvocationID.x*PL_MAX_GRAFTS_PER_SOLUTION + i] = rms;
             
    }    
    
}


