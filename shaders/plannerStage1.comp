#version 430

#define PL_MAX_GRAFTS_PER_SOLUTION  20
#define PL_MAX_DONOR_SITES          5
#define PL_MAX_CAP_TRIANGLES        500

layout (local_size_x = 16) in;

// input data
layout (std430,  binding = 0) buffer defectSiteDataBlock  { vec4 defectSiteData[]; };
layout (std430,  binding = 0) buffer donorSiteDataBlock   { vec4 donorSiteData[];  };

// temporary data
layout (std430,  binding = 1) buffer tempBuffer0          { vec4 tempDefectTriangles[]; };
layout (std430,  binding = 2) buffer tempBuffer1          { vec4 tempDonorTriangles[]; };

// state output
layout (std430,  binding = 5) buffer rmsOutputBlock       { float rmsOutput[]; };

// input uniforms
uniform uint  uGraftCount;
uniform vec4  uGraftPositions [PL_MAX_GRAFTS_PER_SOLUTION];
uniform vec4  uGraftNormals   [PL_MAX_GRAFTS_PER_SOLUTION];
uniform float uGraftRadii     [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint  uDefectSiteMeshSize;

uniform uint  uDonorSiteCount;
uniform uint  uDonorSiteMeshSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSiteGridSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSitePerimSize  [PL_MAX_DONOR_SITES];


struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct edge
{
    vec3 p0;
    vec3 p1;
    vec3 n;
};


triangle defectSiteTriangles( in uint i )
{
    uint j = i*4;    
    triangle t;
    t.p0 = vec3( defectSiteData[j+0] );
    t.p1 = vec3( defectSiteData[j+1] );
    t.p2 = vec3( defectSiteData[j+2] );
    t.n  = vec3( defectSiteData[j+3] );
    return t;
}


void getDonorSiteAndIndex( inout uint site, inout uint localIndex, in uint gid )
{
    localIndex = gid;
    for (uint i=0; i< site; i++)
    {
        if ( localIndex < uDonorSiteGridSize[ i ] )
        {
            site = i;
            break;
        }
        localIndex -= uDonorSiteGridSize[ i ];
    }
}


uint getDonorSiteOffset( in uint site )
{
    uint index = 0;
    for (uint i=0; i< site; i++)
    {
        index+= uDonorSiteGridSize[i]*2 + uDonorSiteMeshSize[i]*4 + uDonorSitePerimSize[i]*2;
    }
    return;
}


vec4 donorSitePositions( in uint site, in uint i )
{   
    return donorSiteData[ getDonorSiteOffset( site ) + i];
}


vec4 donorSiteNormals( in uint site, in uint i )
{
    return donorSiteData[ getDonorSiteOffset( site ) + uDefectSiteGridSize[ site ] + i];
}


triangle donorSiteTriangles( in uint site, in uint i )
{
    uint j = getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ]*2 + i*4;  
    triangle t;
    t.p0 = vec3( donorSiteData[j+0] );
    t.p1 = vec3( donorSiteData[j+1] );
    t.p2 = vec3( donorSiteData[j+2] );
    t.n  = vec3( donorSiteData[j+3] );
    return t;
}


edge donorSiteEdge( in uint site, in uint i )
{
    uint offset = getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ]*2 + uDonorSiteMeshSize[ site ]*4; 

    uint j = offset + i;
    uint k = offset + ( (i+1) % uDonorSitePerimSize[ site ] );
    
    edge e;
    e.p0 = vec3( donorSiteData[ j ] );
    e.p1 = vec3( donorSiteData[ k ] );  
    e.n  = vec3( donorSiteData[ j+uDonorSitePerimSize[ site ] ] );
    return e;
}


uint randomize( inout uint seed )
{   
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}


float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}


vec3 closestPointOnSegment( in vec3 p, in edge e)
{
    vec3 ab = e.p1 - e.p0;
    float t = dot( (p - e.p0), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return e.p0 + t * ab;
}


bool isWithinSite( in uint site, in vec3 pos, in float radius )
{
    bool inside = true;
    for (int i=0; i<uDefectSitePerimSize[ site ]; i++)
    {
        edge e = donorSiteEdge( site, i );
        if ( length( pos - closestPointOnSegment( pos, e) ) < radius )
        {
            inside = false;
        }        
    }    
    return inside;
}


float area( in triangle t)
{
    return 0.5 * length( cross( (t.p1 - t.p0),  (t.p2 - t.p0) ) );
}



float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return length(v - dot(v, axis)*axis);
}


bool intersectTriangle( in vec3 position, in vec3 normal, in triangle t, in float radius ) 
{
    if ( dot(t.n, normal) < 0 )
        return false;

    // get vector from graft centre to triangle point
    vec3 point0 = t.p0 - position;
    vec3 point1 = t.p1 - position;
    vec3 point2 = t.p2 - position;
    
    return ( distToAxis( normal, point0 ) < radius ||
             distToAxis( normal, point1 ) < radius ||
             distToAxis( normal, point2 ) < radius );
  
}


void calculateDonorCap( in vec3 position, in vec3 normal, in float radius )
{ 
    // get global invocation id
    int gid = int(gl_GlobalInvocationID.x);

    uint site, localIndex;
    getSiteAndIndex( site, localIndex, gid );
    
    uint triangleCount = 0;
    
    for(uint i=0; i<uDonorSiteMeshSize[ site ]; i++)
    {
        // create triangle struct
        triangle t = donorSiteTriangles( site, i );

        if ( intersectTriangle( position, normal, t, radius ) )
        {
            tempDonorSiteTriangles[ gid * PL_MAX_CAP_TRIANGLES + triangleCount*4 ] = t.p0;
            tempDonorSiteTriangles[ gid * PL_MAX_CAP_TRIANGLES + triangleCount*4 ] = t.p1;
            tempDonorSiteTriangles[ gid * PL_MAX_CAP_TRIANGLES + triangleCount*4 ] = t.p2;
            tempDonorSiteTriangles[ gid * PL_MAX_CAP_TRIANGLES + triangleCount*4 ] = t.n;
        }
    }
    return triangleCount;
}


void calculateDefectCap( in vec3 position, in vec3 normal, in float radius )
{ 
    // get global invocation id
    int gid = int(gl_GlobalInvocationID.x);

    uint triangleCount = 0;
    
    for(uint i=0; i<uDefectSiteMeshSize; i++)
    {
        // create triangle struct
        triangle t = defectSiteTriangles( site, i );

        if ( intersectTriangle( position, normal, t, radius ) )
        {
            tempDefectSiteTriangles[ gid * PL_MAX_CAP_TRIANGLES + triangleCount*4 ] = t.p0;
            tempDefectSiteTriangles[ gid * PL_MAX_CAP_TRIANGLES + triangleCount*4 ] = t.p1;
            tempDefectSiteTriangles[ gid * PL_MAX_CAP_TRIANGLES + triangleCount*4 ] = t.p2;
            tempDefectSiteTriangles[ gid * PL_MAX_CAP_TRIANGLES + triangleCount*4 ] = t.n;
        }
    }
    return triangleCount;
}


void shuffle( inout array )
{   
    PLuint size = array.size();
    for (PLuint i = 0; i < size-1; i++) 
    {
      PLuint j = i + rand() / (RAND_MAX / (size - i) + 1);
      PLuint t = array[j];
      array[j] = array[i];
      array[i] = t;
    }    
}


bool rayIntersect( inout vec3 point, inout float t, in vec3 rayStart, in vec3 rayDir, in triangle tri )
{
    // Compute ray/plane intersection
    float dn = rayDir * tri.n;

    if (dn == 0 )
    {      
        return false;   // ray is parallel to plane 
    }

    float dist = dot( tri.p0, tri.n );

    float t = (dist - rayStart*tri.n) / dn;
    
    if (ignoreBehindRay && t < 0) 
        return plIntersection(false);   // plane is behind ray

    vec3 point = rayStart + t * rayDir;

    // Compute barycentric coords
    float totalAreaDiv = 1.0 / dot( cross( (tri.p1-t.p0) , (tri.p2-tri.p0) ) , tri.n);
    float u = dot( cross((tri.p2-t.p1) , (point - tri.p1)) , tri.n) * totalAreaDiv;
    float v = dot( cross((tri.p0-t.p2) , (point - tri.p2)) , tri.n) * totalAreaDiv;

    // Reject if outside triangle
    if (u < 0 || v < 0 || u + v > 1)
        return false; 
    
    return true;
}


bool rayIntersectDefect( inout vec3 point, in vec3 rayStart, in vec3 rayDir, in uint count )
{
    vec3 closestPoint;
    float minT;
    for (uint i=0; i<count*4; i+=4)
    {
        triangle t;
        t.p0 = tempDefectTriangles[ i+0 ];
        t.p1 = tempDefectTriangles[ i+1 ];
        t.p2 = tempDefectTriangles[ i+2 ];
        t.n  = tempDefectTriangles[ i+3 ];
        vec3 point;
        float t;
        rayIntersect( point, t, rayStart, rayDir, t ); 
        if ( abs( t ) < minT )
        {
            minT = abs( t );
            closestPoint = point;
        }
    }
}



bool rayIntersectDonor( inout vec3 point, in vec3 rayStart, in vec3 rayDir, in uint count )
{
    vec3 closestPoint;
    float minT;
    for (uint i=0; i<count*4; i+=4)
    {
        triangle t;
        t.p0 = tempDonorTriangles[ i+0 ];
        t.p1 = tempDonorTriangles[ i+1 ];
        t.p2 = tempDonorTriangles[ i+2 ];
        t.n  = tempDonorTriangles[ i+3 ];
        vec3 point;
        float t;
        rayIntersect( point, t, rayStart, rayDir, t ); 
        if ( abs( t ) < minT )
        {
            minT = abs( t );
            closestPoint = point;
        }
    }
}


float calcRMS( in uint defectCount, in uint donorCount )
{
    vec3 pos[1];
    pos[0] = vec3(0,0,0);
    uint numPoints = 1;
    
    float squaredDistanceSum = 0;
    for (uint i=0; i<numPoints; i++)
    {
        vec3 defectPoint, donorPoint;
        rayIntersectDefect( defectPoint, pos[i], uStateGraftNormal, defectCount );
        rayIntersectDefect( donorPoint,  pos[i], uStateGraftNormal, donorCount );
        squaredDistanceSum += distance(defectPoint, donorPoint) * distance(defectPoint, donorPoint);
    }

    return squaredDistanceSum / float( numPoints );
}


void main(void)
{ 
    // get global invocation id
    int gid = int( gl_GlobalInvocationID.x );    
    
    uint site, localIndex;
    getSiteAndIndex( site, localIndex, gid );
    
    vec3 gridPoint = donorSitePosition( site, localIndex );
    
    // for each graft
    for (uint i=0; i<uGraftCount; i++)
    {
        float rms;
        if ( isWithinSite( site, gridPoint, uGraftRadii[i] ) )
        {
            // calculate defect cap triangles and store in temp buffer
            uint defectCount = calculateDefectCap( uGraftPositions[i], uGraftNormals[i], uGraftRadii[i] );
            // calculate cap triangles and store in temp buffer
            uint donorCount = calculateDonorCap( gridPoint, uGraftNormals[i], uGraftRadii[i] );
            // calculate rms error
            rms = calcRMS( defectCount, donorCount );  
        }
        else
        {
            // doesnt fit in boundary
            rms = -1;
        }
        rmsOutput[ gid*PL_MAX_GRAFTS_PER_SOLUTION + i] = rms;
             
    }    
    
}


