#version 430

#define PL_MAX_GRAFT_CAP_TRIANGLES  1000
#define PL_MAX_GRAFTS_PER_SOLUTION  20

layout (local_size_x = 1024) in;

// input textures
layout (rgba32f, binding = 0) uniform image2D  iGraftCaps;
layout (r32f,    binding = 1) uniform image1D  iGraftAreas;
layout (r32ui,   binding = 2) uniform uimage2D iGraftTriangles;

layout (rgba32f, binding = 3) uniform image2D iSiteMeshTriangles;

// input uniforms
uniform uint  uSiteMeshSize;
uniform float uSiteArea;

uniform float uTemperature;
uniform float uStateEnergy;
uniform uint  uStateGrafts[PL_MAX_GRAFTS_PER_SOLUTION];

// output textures
layout (r32f,  binding = 4) uniform image1D  oStateEnergies;
layout (r32ui, binding = 5) uniform uimage2D oStateGrafts;

// temporary
layout (r32f, binding = 6) uniform image2D tTriangleAreas;

struct state
{
    uint  grafts[PL_MAX_GRAFTS_PER_SOLUTION];
    float energy;
};


struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


float area( in triangle t)
{
    return 0.5 * length( cross( (t.p1 - t.p0),  (t.p2 - t.p0) ) );
}

/*

void projectCap( int capID )
{
    vec3 plane_point = vec3( imageLoad( iSiteMeshTriangles, ivec2(0,0) ) ); // any point will doo

    for (uint i=0; i<PL_MAX_GRAFT_CAP_TRIANGLES; i++)
    {       
        vec3 p = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,0) ) );
        vec3 v = p - plane_point;
        
        float dist = dot( v, n );
        
        vec3 projected = p - dist*uSiteNormal; 
    }

}
*/


float area_covered( in state s )
{
    uint capCount = s.grafts[0];
    float total_area = 0;
    for (uint i = 1; i <= capCount; i++)
    {   
        // add area of cap to sum, includes overlaps
        total_area += imageLoad( iGraftAreas, int(s.grafts[i]) ); 
    }
    return total_area;
}


float area_uncovered( in state s )
{       
    int gid = int( gl_GlobalInvocationID.x ); 
         
    uint capCount = s.grafts[0];
    
    // for each graft in current state
    for (uint i = 1; i <= capCount; i++)
    {   
        uint num_overlapping_triangles = imageLoad( iGraftTriangles, ivec2(0, s.grafts[i]) );
        
        // for each triangle in that graft
        for (uint j = 1; j <= num_overlapping_triangles; j++)
        { 
            // get index of overlapped triangle
            uint t_index = imageLoad( iGraftTriangles, ivec2(j, s.grafts[i]) );
            // get triangle
            triangle t;
            t.p0 = vec3( imageLoad( iSiteMeshTriangles, ivec2(t_index,0) ) );
            t.p1 = vec3( imageLoad( iSiteMeshTriangles, ivec2(t_index,1) ) );
            t.p2 = vec3( imageLoad( iSiteMeshTriangles, ivec2(t_index,2) ) );
            // set area of triangle to be summed later
            imageStore( tTriangleAreas, ivec2( t_index, gid ), vec4( area(t), 0, 0, 0) );

        }       
    }
    
    float non_overlap_area = 0;
    
    // iterate over triangles, if they are in cap, value > 0, add to sum
    for (uint i = 0; i < uSiteMeshSize; i++)
    {  
         non_overlap_area += imageLoad( tTriangleAreas, ivec2(i, gid) ); 
    }      
    
    return uSiteArea - non_overlap_area;
}


float energy ( in state s )
{
    float WEIGHT = 0.4;
    return area_uncovered( s ) + WEIGHT * area_covered( s );
}


void addCap( inout state s, in uint index )
{    
    s.grafts[0]++; 
    uint capCount = s.grafts[0];   
    s.grafts[capCount] = index;       
}


void removeCap( inout state s, in uint index )
{
    uint capCount = s.grafts[0];    
    // shift all other elements down
    for (uint i=index; i<=capCount; i++)
    {
        if (i+1 == PL_MAX_GRAFTS_PER_SOLUTION)  // max sure doesnt go out of bounds
            s.grafts[i] = 0;
            
        s.grafts[i] = s.grafts[i+1];       
    }
    s.grafts[0]--;
}


int isInState( in state s, in int gid )
{
    uint capCount = s.grafts[0]; 
    for (int i=1; i<=capCount; i++)
    {
        if (s.grafts[i] == gid)
        {
            return i; 
        }
    }
    return -1;
}


void copyGlobalState( inout state s )
{
    uint capCount = uStateGrafts[0];
    s.grafts[0] = capCount;
    for (uint i=1; i<=capCount; i++)
    {    
        s.grafts[i] = uStateGrafts[i];
    }
    s.energy = uStateEnergy;
}


void main(void)
{ 
    // get global invocation id
    int gid = int( gl_GlobalInvocationID.x );    
    
    // copy initial state 
    state nS; 
    copyGlobalState( nS );
    
    // check if inside state
    int indexInState = isInState( nS, gid );
    
    if ( indexInState > 0 )
    {
        // remove self        
        removeCap( nS, uint(indexInState) );         
    }
    else
    {
        // add self
        addCap( nS, gid );
    }

    // calc energy
    nS.energy = energy( nS );    
    
    // store state energy
    imageStore( oStateEnergies, gid, vec4( nS.energy, 0, 0, 0 ) );
    // store state cap indices
    
    for (int i=0; i<=nS.grafts[0]; i++)
    {
        imageStore( oStateGrafts, ivec2( i, gid ), uvec4( nS.grafts[i], 0, 0, 0) );    
    }
    
}


