#version 430

#define PL_NUM_WORKGROUPS           16
#define PL_WORKGROUP_SIZE           64
#define PL_MAX_GRAFTS_PER_SOLUTION  16
#define PL_MAX_RADIUS               4.0
#define PL_MIN_RADIUS               3.0
#define PL_OVERLAP_THRESHOLD        0.8
#define PL_GRAFT_LENGTH             15.0
#define PL_INTERSECTION_PENALTY     3.0
#define PL_MIN_PERTURBATION         0.05

layout (local_size_x = PL_WORKGROUP_SIZE) in;

// shader storage buffer objects
layout (std430,  binding = 0) buffer siteDataBlock        { vec4 siteData[]; };

// temporary buffer
layout (std430,  binding = 1) buffer tempBuffer           { float overlappedTriangles[]; };

// invocation output buffers

// TODO: HAVE INPUT GRID BE FIXED SIZE? USE SINGLE BUFFER?

layout (std430,  binding = 2) buffer invoEnergiesBlock    { float invoEnergies      []; };
layout (std430,  binding = 3) buffer StatePositionBlock   { vec4  invoGraftPositions[]; };
layout (std430,  binding = 4) buffer StateNormalBlock     { vec4  invoGraftNormals  []; };
layout (std430,  binding = 5) buffer StateRadiiBlock      { float invoGraftRadii    []; };
layout (std430,  binding = 6) buffer StateGraftCountBlock { uint  invoGraftCounts   []; };

// work group input buffers
layout ( std430, binding = 7 ) buffer workGroupStates
{
    float groupEnergies       [ PL_NUM_WORKGROUPS ];
    uint  groupGraftCounts    [ PL_NUM_WORKGROUPS ];
    vec4  groupGraftPositions [ PL_NUM_WORKGROUPS * PL_MAX_GRAFTS_PER_SOLUTION ];
    vec4  groupGraftNormals   [ PL_NUM_WORKGROUPS * PL_MAX_GRAFTS_PER_SOLUTION ];
    float groupGraftRadii     [ PL_NUM_WORKGROUPS * PL_MAX_GRAFTS_PER_SOLUTION ];         
};


// site uniforms
uniform uint  uSiteMeshSize;
uniform float uSiteMeshArea;
uniform uint  uSiteGridSize;
uniform uint  uSitePerimSize;
uniform vec4  uSiteNormal;

uniform float uTemperature;
uniform uint  uSeed;
uniform uint  uLoadLocal;


struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct edge
{
    vec3 p0;
    vec3 p1;
    vec3 n;
};


struct state
{
    vec4  positions     [PL_MAX_GRAFTS_PER_SOLUTION];
    vec4  normals       [PL_MAX_GRAFTS_PER_SOLUTION];
    float radii         [PL_MAX_GRAFTS_PER_SOLUTION];
    uint  graftCount;
    float energy;
};


void setOverlap( in uint index, in float value )
{
    overlappedTriangles[gl_GlobalInvocationID.x*uSiteMeshSize + index] = value;
}


float getOverlap( in uint index )
{
    return overlappedTriangles[gl_GlobalInvocationID.x*uSiteMeshSize + index];
}


vec4 sitePositions( in uint i )
{
    return siteData[i];
}


vec4 siteNormals( in uint i )
{
    return siteData[uSiteGridSize+i];
}


triangle siteTriangles( in uint i )
{
    uint j = uSiteGridSize*2 + i*4;    
    triangle t;
    t.p0 = vec3( siteData[j+0] );
    t.p1 = vec3( siteData[j+1] );
    t.p2 = vec3( siteData[j+2] );
    t.n  = vec3( siteData[j+3] );
    return t;
}


edge siteEdge( in uint i )
{
    uint offset = uSiteGridSize*2 + uSiteMeshSize*4;
    uint j = offset + i;
    uint k = offset + ( (i+1) % uSitePerimSize );
    
    edge e;
    e.p0 = vec3( siteData[ j ] );
    e.p1 = vec3( siteData[ k ] );  
    e.n  = vec3( siteData[ j+uSitePerimSize ] );   // tangent pointing out 
    return e;
}


vec3 projectOntoPlane( in vec3 point, in vec3 plane_normal )
{
    float dist = dot( point, plane_normal);    
    return point - (dist * plane_normal);
}


float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return distance( v, dot(v, axis)*axis );
}


vec3 closestPointOnSegment( in vec3 p, in vec3 a, in vec3 b)
{
    vec3 ab = b - a;
    float t = dot( (p - a), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return a + (t * ab);
}


vec3 closestPointOnSegment( in vec3 p, in edge e)
{
    return closestPointOnSegment( p, e.p0, e.p1 );
}


bool isWithinOverlapThreshold( in vec3 position, in vec3 normal, in float threshold )
{
    // checks if closest point on all edges is within radius distance to the grafts central axis
    bool inside = true;
    for (int i=0; i<uSitePerimSize; i++)
    {
        edge e = siteEdge( i );     
        
        /* check if outside boundary   
        if ( dot( position-e.p0, e.n ) > 0.0 )
            inside = false;
        */
        
        vec3 closestPoint     = closestPointOnSegment( position, e ) - position;    // get closest point in graft coords        
        vec3 projClosestPoint = dot( closestPoint, normal ) * normal;               // get closest point projected onto graft axis 
        // check if within threshold distance       
        if ( distance( closestPoint, projClosestPoint ) < threshold ) 
        {
            inside = false;
            break;
        }        
    }    
    return inside;
}


bool isWithinRotationThreshold( in vec3 normal, in float threshold )
{
    return acos( dot( normal, vec3(uSiteNormal) ) ) < threshold* 0.01745329;

}


float sphereIntersectionDistance( in vec3 position0, in float radius0, in vec3 position1, in float radius1 )
{

    float intDistance = (radius0+radius1) - distance( position0, position1 );
    // return itnersection distance
    return (intDistance > 0) ? intDistance : 0.0;
}


void closestPointsOnTwoSegments( inout vec3 c0, inout vec3 c1, in vec3 position0, in vec3 normal0, in vec3 position1, in vec3 normal1 )
{
    vec3 d0 = -normal0*PL_GRAFT_LENGTH; // Direction vector of segment S0
    vec3 d1 = -normal1*PL_GRAFT_LENGTH; // Direction vector of segment S1
    vec3 r = position0 - position1;
    float a = dot( d0, d0 ); // Squared length of segment S0, always nonnegative
    float e = dot( d1, d1 ); // Squared length of segment S1, always nonnegative
    float f = dot( d1, r );
    float c = dot( d0, r );
    
    // The general non-degenerate case starts here, no degenerate cases considered ( no grafts are 0 length )
    float b = dot(d0, d1);
    float denom = a*e-b*b; // Always nonnegative
    // If segments not parallel, compute closest point on L1 to L2 and
    // clamp to segment S1. Else pick arbitrary s (here 0)
    float s, t;
    
    if (denom != 0.0) 
    {
        s = clamp( (b*f - c*e) / denom, 0.0, 1.0 );
    } 
    else
    { 
        s = 0.0;
    }  
    // Compute point on L2 closest to S1(s) using
    // t = Dot((P1 + D1*s) - P2,D2) / Dot(D2,D2) = (b*s + f) / e
    t = (b*s + f) / e;
    // If t in [0,1] done. Else clamp t, recompute s for the new value
    // of t using s = Dot((P2 + D2*t) - P1,D1) / Dot(D1,D1)= (t*b - c) / a
    // and clamp s to [0, 1]
    if( t < 0.0 ) 
    {
        t = 0.0;
        s = clamp(-c / a, 0.0, 1.0);
    } 
    else if ( t > 1.0 ) 
    {
        t = 1.0;
        s = clamp((b - c) / a, 0.0, 1.0);
    }

    c0 = position0 + d0 * s;
    c1 = position1 + d1 * t;
}


float cylinderOverlapEnergy( in vec3 position0, in vec3 normal0, in float radius0, in vec3 position1, in vec3 normal1, in float radius1 )
{
    // get closest points on each graft to eachother
    vec3 closest0, closest1;
    closestPointsOnTwoSegments( closest0, closest1, position0, normal0, position1, normal1 );
    // return intersection depth ( 0 if not intersecting )
    return sphereIntersectionDistance( closest0, radius0, closest1, radius1 ) * PL_INTERSECTION_PENALTY;
}


float overlapEnergy( in state s )
{   
    float energy = 0;
    for (uint i=0; i < s.graftCount; i++)
    {
        for (uint j=i+1; j < s.graftCount; j++)
        {
            energy += cylinderOverlapEnergy( vec3( s.positions[i] ), vec3( s.normals[i] ), s.radii[i], 
                                             vec3( s.positions[j] ), vec3( s.normals[j] ), s.radii[j] );
        }
    }
    return energy;
}


uint randomize( inout uint seed )
{   
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}


float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}


bool graftIntersectTriangle( in vec3 position, in vec3 normal, in triangle t, in float radius ) 
{
    if ( dot( t.n, normal ) < 0.0 )
        return false;

    // get vector from graft centre to triangle point
    return ( distToAxis( normal, t.p0 - position ) < radius ||
             distToAxis( normal, t.p1 - position ) < radius ||
             distToAxis( normal, t.p2 - position ) < radius );
}


float area( in triangle t)
{
    return 0.5 * length( cross( (t.p1 - t.p0),  (t.p2 - t.p0) ) );
}


float area_uncovered( in state s )
{           
    float overlapped_area = 0;    
    // iterate over triangles, if they are in cap, value > 0, add to sum
    for (uint i = 0; i < uSiteMeshSize; i++)
    {        
         overlapped_area += getOverlap( i );   
         setOverlap( i, 0 );   
    }          
    return uSiteMeshArea - overlapped_area;
}


float calculateCap( in vec4 position, in vec4 normal, in float radius )
{   
    float area_sum = 0;

    // iterate through each triangle in mesh
    for(uint i=0; i<uSiteMeshSize; i++)
    {
        // create triangle struct
        triangle t = siteTriangles( i );

        if ( intersectTriangle( vec3( position ), vec3( normal ),  t, radius ) )  
        {
            float t_area = area( t );
            area_sum += t_area;  
            setOverlap( i, t_area ); 
        }  
    }
    return area_sum;
}

void rotate( inout mat4 mat, in float angle, in vec3 axis ) 
{
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    // all angles in radians
    float s = sin( angle*0.017453292 );
    float c = cos( angle*0.017453292 );

    float mag = length( axis ); 

    // zero vector, return identity
    if (mag == 0.0) 
    {
        mat = mat4(1.0);
        return;
    }

    // Rotation matrix is normalized
    x /= mag;
    y /= mag;
    z /= mag;

    float xx, yy, zz, xy, yz, zx, xs, ys, zs, one_c;
    xx = x * x;
    yy = y * y;
    zz = z * z;
    xy = x * y;
    yz = y * z;
    zx = z * x;
    xs = x * s;
    ys = y * s;
    zs = z * s;
    one_c = 1.0f - c;

    mat = mat4(1.0);
    
    mat[0][0] = (one_c * xx) + c;
    mat[0][1] = (one_c * xy) - zs;
    mat[0][2] = (one_c * zx) + ys;

    mat[1][0] = (one_c * xy) + zs;
    mat[1][1] = (one_c * yy) + c;
    mat[1][2] = (one_c * yz) - xs;
    
    mat[2][0] = (one_c * zx) - ys;
    mat[2][1] = (one_c * yz) + xs;
    mat[2][2] = (one_c * zz) + c;
}


float energy ( in state s )
{
    float total_area_covered = 0;   // includes overlaps
    for (uint i=0; i<s.graftCount; i++)
    {
         // calculate cap returns area from the cap, and also flags any overlapped triangles
         total_area_covered += calculateCap( s.positions[i], s.normals[i], s.radii[i] ); 
    }

    // calculate energy
    float WEIGHT = 0.6;
    return area_uncovered( s ) + /*WEIGHT * total_area_covered;//*/ + overlapEnergy( s );
}


void addCap( inout state s, inout uint seed )
{   
    float radius = uint( rand( seed ) * (PL_MAX_RADIUS-PL_MIN_RADIUS+1) + PL_MIN_RADIUS); 
    uint  index  = uint( uSiteGridSize*rand( seed ) );
    
    if ( isWithinOverlapThreshold( vec3( sitePositions( index ) ), vec3( siteNormals( index ) ), radius*PL_OVERLAP_THRESHOLD ) )
    {    
        s.positions[s.graftCount] = sitePositions( index );
        s.normals  [s.graftCount] = siteNormals  ( index );
        s.radii    [s.graftCount] = radius;   
        s.graftCount++;  
    }
}


void removeCap( inout state s, inout uint seed )
{ 
    uint index = uint( s.graftCount*rand( seed ) );
    
    // shift all other elements down
    for (uint i=index; i<s.graftCount; i++)
    {
        if (i+1 == PL_MAX_GRAFTS_PER_SOLUTION)  // max sure doesnt go out of bounds
        {
            s.positions[i] = vec4(-1, -1, -1, -1);
            s.normals  [i] = vec4(-1, -1, -1, -1);
            s.radii    [i] = -1.0; 
        }    
        s.positions[i] = s.positions[i+1];
        s.normals  [i] = s.normals  [i+1];
        s.radii    [i] = s.radii    [i+1];                              
    }
    s.graftCount--;
}




void perturbState( inout state s, inout uint seed )
{
    
    float perturbationScale = ( uTemperature > PL_MIN_PERTURBATION ) ? uTemperature : rand( seed ) * PL_MIN_PERTURBATION; 
    
    for (uint i=0; i<s.graftCount; i++)
    {       
        // get random rotation        
        float angle = ((rand( seed )*2.0)-1.0) * perturbationScale * 5.0;
        float x = rand( seed );
        float y = rand( seed );
        float z = rand( seed );    
        vec3 axis = normalize( vec3( x, y, z ) );
        mat4 rot;   rotate( rot, angle, axis ); 
        
        // get random translation
        float tx = rand( seed );
        float ty = rand( seed );
        float tz = rand( seed ); 

        vec3 graftNormal   = vec3( s.normals[i] ); 

        vec3 projectedTrans = projectOntoPlane( vec3( tx, ty, tz ), graftNormal );           
        vec3 trans          = normalize( projectedTrans ) * ( ((rand( seed )*2.0)-1.0) * perturbationScale);

        vec3 graftPosition = vec3( s.positions[i] ) + trans;
        

        if ( isWithinOverlapThreshold( graftPosition, graftNormal, s.radii[i]*PL_OVERLAP_THRESHOLD ) )    
        {
            s.positions[i] = vec4( graftPosition, 1.0 );
            
        }

        graftNormal = normalize( vec3( rot * vec4( graftNormal, 0.0 ) ) );   
            
        if ( isWithinRotationThreshold( graftNormal, 25.0 ) )
        {
            s.normals[i]   = vec4( graftNormal, 1.0 );
        }    

    }
}


void copyGlobalState( inout state s )
{
    uint offset = gl_WorkGroupID.x*PL_MAX_GRAFTS_PER_SOLUTION;

    s.graftCount = groupGraftCounts[ gl_WorkGroupID.x ];
    s.energy     = groupEnergies   [ gl_WorkGroupID.x ];
    
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = groupGraftPositions[offset+i];
        s.normals  [i] = groupGraftNormals  [offset+i];
        s.radii    [i] = groupGraftRadii    [offset+i];
    } 
}


void copyLocalState( inout state s )
{
    uint offset = gl_GlobalInvocationID.x*PL_MAX_GRAFTS_PER_SOLUTION;  

    s.graftCount = invoGraftCounts[ gl_GlobalInvocationID.x ];
    s.energy     = invoEnergies   [ gl_GlobalInvocationID.x ];
    
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = invoGraftPositions[offset+i];
        s.normals  [i] = invoGraftNormals  [offset+i];
        s.radii    [i] = invoGraftRadii    [offset+i];
    }    
}


void main(void)
{ 
    // get global invocation id
    uint gid = gl_GlobalInvocationID.x;  
      
    // get invocation unique seed value for RNG
    uint seed = uint( uSeed*(gid+1) );  
    
    // acquire current state (whether global or local)  
    state nS;   
    if ( uLoadLocal > 0 )  
    {       
        copyLocalState( nS );
    }
    else   
    {
        copyGlobalState( nS );         
    }
   
    // determine which case
    uint changeCase = uint( rand( seed ) * 20 );
        
    if (nS.graftCount == 0 || changeCase == 0)
    {
        // add random
        if (nS.graftCount < PL_MAX_GRAFTS_PER_SOLUTION)
        {
            addCap( nS, seed );
        }
    }
    else if (changeCase == 1)
    {
        // remove random
        removeCap( nS, seed );
    }
             
    // peturb state
    perturbState( nS, seed );
    
    if ( uLoadLocal == 1 )
    {
        // calc energy on last local iteration
        nS.energy = energy( nS );             
    }
    
    // store state energy
    invoEnergies[gid] = nS.energy;
    
    // store state graft count
    invoGraftCounts[gid] = nS.graftCount;

    // store state positions, normals, and radii  
    uint offset = gid*PL_MAX_GRAFTS_PER_SOLUTION;  
    for (int i=0; i<nS.graftCount; i++)
    {
        invoGraftPositions[offset+i] = nS.positions[i];
        invoGraftNormals  [offset+i] = nS.normals  [i]; 
        invoGraftRadii    [offset+i] = nS.radii    [i];   
    } 
}


