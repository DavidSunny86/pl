#version 430

#define PL_MAX_GRAFTS_PER_SOLUTION  20
#define PL_MAX_RADIUS               4.0
#define PL_MIN_RADIUS               2.0
#define PL_OVERLAP_THRESHOLD        0.9

layout (local_size_x = 512) in;

// shader storage buffer objects
layout (std430,  binding = 0) buffer siteDataBlock        { vec4 siteData[]; };

// temporary buffer
layout (std430,  binding = 1) buffer tempBuffer           { float overlappedTriangles[]; };

// output buffers
layout (std430,  binding = 2) buffer StateEnergiesBlock   { float stateEnergies      []; };
layout (std430,  binding = 3) buffer StatePositionBlock   { vec4  stateGraftPositions[]; };
layout (std430,  binding = 4) buffer StateNormalBlock     { vec4  stateGraftNormals  []; };
layout (std430,  binding = 5) buffer StateRadiiBlock      { float stateGraftRadii    []; };
layout (std430,  binding = 6) buffer StateGraftCountBlock { uint  stateGraftCounts   []; };

// input uniforms
uniform uint  uSiteMeshSize;
uniform float uSiteMeshArea;
uniform uint  uSiteGridSize;
uniform uint  uSitePerimSize;

uniform float uStateTemperature;
uniform float uStateEnergy;
uniform uint  uStateGraftCount;
uniform vec4  uStateGraftPositions [PL_MAX_GRAFTS_PER_SOLUTION];
uniform vec4  uStateGraftNormals   [PL_MAX_GRAFTS_PER_SOLUTION];
uniform float uStateGraftRadii     [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint uSeed;

struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct gridPoint
{
    vec3 p;
    vec3 n;
};


struct edge
{
    vec3 p0;
    vec3 p1;
    vec3 n;
};

struct state
{
    vec4  positions     [PL_MAX_GRAFTS_PER_SOLUTION];
    vec4  normals       [PL_MAX_GRAFTS_PER_SOLUTION];
    float radii         [PL_MAX_GRAFTS_PER_SOLUTION];
    uint  graftCount;
    float energy;
};

void setOverlap( in uint index, in float value )
{
    overlappedTriangles[gl_GlobalInvocationID.x*uSiteMeshSize + index] = value;
}

float getOverlap( in uint index )
{
    return overlappedTriangles[gl_GlobalInvocationID.x*uSiteMeshSize + index];
}

vec4 iSitePositions( in uint i )
{
    return siteData[i];
}

vec4 iSiteNormals( in uint i )
{
    return siteData[uSiteGridSize+i];
}

triangle iSiteTriangles( in uint i )
{
    uint j = uSiteGridSize*2 + i*4;    
    triangle t;
    t.p0 = vec3( siteData[j+0] );
    t.p1 = vec3( siteData[j+1] );
    t.p2 = vec3( siteData[j+2] );
    t.n  = vec3( siteData[j+3] );
    return t;
}

edge iSiteEdge( in uint i )
{
    uint offset = uSiteGridSize*2 + uSiteMeshSize*4;
    uint j = offset + i;
    uint k = offset + ( (i+1) % uSitePerimSize );
    
    edge e;
    e.p0 = vec3( siteData[ j ] );
    e.p1 = vec3( siteData[ k ] );  
    e.n  = vec3( siteData[ j+uSitePerimSize ] );    
    return e;
}

vec3 projectOntoPlane( in vec3 point, in vec3 plane_normal )
{
    float dist = dot( point, plane_normal);
    
    return point - (dist * plane_normal);
}

float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return length(v - dot(v, axis)*axis);
}

vec3 closestPointOnSegment( in vec3 p, in edge e)
{
    vec3 ab = e.p1 - e.p0;
    float t = dot( (p - e.p0), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return e.p0 + t * ab;
}

bool isWithinOverlapThreshold( in vec3 pos, in float threshold )
{
    bool inside = true;
    for (int i=0; i<uSitePerimSize; i++)
    {
        edge e = iSiteEdge( i );
        if ( length( pos - closestPointOnSegment( pos, e) ) < threshold )
        {
            inside = false;
        }        
    }    
    return inside;
}

bool isValidPerturbation( in vec3 pos, in float threshold )
{
    bool inside = true;
    for (int i=0; i<uSitePerimSize; i++)
    {
        edge e = iSiteEdge( i );
        if ( dot( pos-e.p0, e.n ) > 0.0 ||
             length( pos - closestPointOnSegment( pos, e) ) < threshold)
        {
            inside = false;
        }        
    }    
    return inside;
}

uint randomize( inout uint seed )
{   
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    return seed;
}

float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}

/*
vec3 pointOnCircumference( in vec3 u, in vec3 v, in float radius )
{
    float a = dot( (v-u), (v-u) );
    float b = 2 * dot( u, (v-u) );
    float c = dot( u, u ) - radius*radius;

    float radical = b*b - 4*a*c;
    
    if (radical < 0) 
    {
        // error
        return vec3(0,0,0);	
    }

    float root = sqrt(radical);

    float t1 = (-b + root)/(2*a);
    float t2 = (-b - root)/(2*a);

    float t;
    if (t1 >= 0 && t1 <= 1 && (t1 <= t2 || t2 <= 0))
    {
        t = t1;
    }
    else if (t2 >= 0 && t2 <= 1 && (t2 <= t1 || t1 >= 1))
    {
        t = t2;
    }
    else 
    {
        // error
        return vec3(0,0,0);	
    }

    return u + t*(v-u);   
}
*/

bool intersectTriangle( /*out triangle tri[2], */in gridPoint g, in triangle t, in float radius ) 
{
    if ( dot(t.n, g.n) < 0 )
        return false;

    // get vector from graft centre to triangle point
    vec3 point0 = t.p0 - g.p;
    vec3 point1 = t.p1 - g.p;
    vec3 point2 = t.p2 - g.p;
    
    return ( distToAxis( g.n, point0 ) < radius ||
             distToAxis( g.n, point1 ) < radius ||
             distToAxis( g.n, point2 ) < radius );
    
    // Compute distance to graft axis
    /*
    float dist0 = distToAxis( g.n, point0 );
    float dist1 = distToAxis( g.n, point1 );
    float dist2 = distToAxis( g.n, point2 );
    
    // If too far from graft axis, reject.  Note that this will miss some slightly-overlapping triangles!
    float minDist = min( dist0, min( dist1, dist2 ) );
    
    if ( minDist > radius )
    {
        // no vertices are inside      
        return 0;
    }
    
    // calculate the projected distance on the axis (normal)  
    float proj0 = dot( point0, g.n );
    float proj1 = dot( point1, g.n );
    float proj2 = dot( point2, g.n );

    float maxProj = max( proj0, max( proj1, proj2 ) );
    float minProj = min( proj0, min( proj1, proj2 ) );
    
    float VERTICAL_THRESHOLD = 8.0f;
        
    if (minProj > VERTICAL_THRESHOLD || maxProj < -VERTICAL_THRESHOLD)
        return 0;   
    
    // If entirely within the graft, accept the whole triangle (this is cheaper).
    float maxDist = max( dist0, max( dist1, dist2 ) );

    if (maxDist <= radius) 
    {
        tri[0].p0 = t.p0;
        tri[0].p1 = t.p1;
        tri[0].p2 = t.p2; 
        tri[0].n  = t.n;
        return 1;
    }
    
    // Not entirely within the graft, so find the intersection of the
    // triangle with the cylinder wall

    // Find a first vertex that is inside

    vec3  vs[3];
    float ds[3];
  
    if (dist0 <= radius) 
    {
        vs[0] = t.p0; ds[0] = dist0;
        vs[1] = t.p1; ds[1] = dist1;
        vs[2] = t.p2; ds[2] = dist2;
    } 
    else if (dist1 <= radius)
    {
        vs[0] = t.p1; ds[0] = dist1;
        vs[1] = t.p2; ds[1] = dist2;
        vs[2] = t.p0; ds[2] = dist0;
    } 
    else 
    {    
        vs[0] = t.p2; ds[0] = dist2;
        vs[1] = t.p0; ds[1] = dist0;
        vs[2] = t.p1; ds[2] = dist1;
    }

    bool prevInside = true; // always starts as true (ds[0] <= radius)

    vec3 points[4];
    int count = 0;
    
    for (int i=0; i<3; i++) 
    {
        int j = (i+1) % 3;		// vertex at next end of edge

        bool nextInside = (ds[j] <= radius);

        if (prevInside && nextInside) 
        {
            // Add inside triangle point
            points[count++] = vs[j];
        } 
        else if (prevInside && !nextInside) 
        {
            // Find point on edge of graft
            points[count++] = pointOnCircumference( (vs[i]-g.p), (vs[j]-g.p), radius ) + g.p;
        } 
        else if (!prevInside && nextInside) 
        {
            // Find entering point and angle 
            points[count++] = pointOnCircumference( (vs[i]-g.p), (vs[j]-g.p), radius ) + g.p;
            // Add inside triangle point    
            points[count++] = vs[j];
        }

        prevInside = nextInside;
    }

    tri[0].p0 = points[0];
    tri[0].p1 = points[1];
    tri[0].p2 = points[2];
    tri[0].n = t.n;
    
    if (count == 4)
    {
        // polygons reach a max of 4 vertices, so if there are 4, create a second triangle
        tri[1].p0 = points[0];
        tri[1].p1 = points[2];
        tri[1].p2 = points[3];
        tri[1].n = t.n;
        return 2;
    }
    return 1;
    */
}


float area( in triangle t)
{
    return 0.5 * length( cross( (t.p1 - t.p0),  (t.p2 - t.p0) ) );
}


float area_uncovered( in state s )
{       
    int gid = int( gl_GlobalInvocationID.x ); 
         
    float overlapped_area = 0;    
    // iterate over triangles, if they are in cap, value > 0, add to sum
    for (uint i = 0; i < uSiteMeshSize; i++)
    {        
         overlapped_area += getOverlap( i ); //imageLoad( tOverlappedTriangleAreas, ivec2( i, gid ) );        
    }      
    
    return uSiteMeshArea - overlapped_area;
}


float calculateCap( in vec4 position, in vec4 normal, in float radius ) //in uint index, in mat4 perturbation )
{   
    int gid = int( gl_GlobalInvocationID.x ); 
  
    gridPoint g;    
    g.p = vec3( position );
    g.n = vec3( normal );
    
    float area_sum = 0;

    // iterate through each triangle in mesh
    for(uint i=0; i<uSiteMeshSize; i++)
    {
        // create triangle struct
        triangle t = iSiteTriangles( i );

        if ( intersectTriangle( g, t, radius ) )  
        {
            float t_area = area( t );
            area_sum += t_area;  
            setOverlap( i, t_area ); 
        }

        /*
        triangle tris[2];   // triangle(s) to be added to graft cap
        int num_results = intersectTriangle( tris, g, t, radius );  // num_results is the number of triangles returned, 0 <= t <= 2

        float tri_area = 0;

        for (uint j=0; j<num_results; j++)
        {
            // accumulate area
            tri_area += area( tris[j] );              
        }  
        
        area_sum += tri_area;
        
        // store overlapped triangle indices
        if (num_results > 0)
        {   
            // if partial area is > 50% full triangle area, flag as overlapped
            if ( tri_area > (area( t )*0.5) )            
                imageStore( tOverlappedTriangleAreas, ivec2( i, gid ), vec4( area(t), 0, 0, 0) );  
        }
        */               
    }
    return area_sum;
}

void rotate( inout mat4 mat, in float angle, in vec3 axis ) 
{
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    // all angles in radians
    float s = sin( angle*0.017453292 );
    float c = cos( angle*0.017453292 );

    float mag = length( axis ); 

    // zero vector, return identity
    if (mag == 0.0) 
    {
        mat = mat4(1.0);
        return;
    }

    // Rotation matrix is normalized
    x /= mag;
    y /= mag;
    z /= mag;

    float xx, yy, zz, xy, yz, zx, xs, ys, zs, one_c;
    xx = x * x;
    yy = y * y;
    zz = z * z;
    xy = x * y;
    yz = y * z;
    zx = z * x;
    xs = x * s;
    ys = y * s;
    zs = z * s;
    one_c = 1.0f - c;

    mat = mat4(1.0);
    
    mat[0][0] = (one_c * xx) + c;
    mat[0][1] = (one_c * xy) - zs;
    mat[0][2] = (one_c * zx) + ys;

    mat[1][0] = (one_c * xy) + zs;
    mat[1][1] = (one_c * yy) + c;
    mat[1][2] = (one_c * yz) - xs;
    
    mat[2][0] = (one_c * zx) - ys;
    mat[2][1] = (one_c * yz) + xs;
    mat[2][2] = (one_c * zz) + c;
}


float energy ( in state s )
{
    float total_area_covered = 0;   // includes overlaps
    for (uint i=0; i<s.graftCount; i++)
    {
         // calculate cap returns area from the cap, and also flags any overlapped triangles
         // in the temporary texture 'tOverlappedTriangleAreas'
         total_area_covered += calculateCap( s.positions[i], s.normals[i], s.radii[i] ); 
    }

    // calculate energy
    float WEIGHT = 0.3;
    return area_uncovered( s ) + WEIGHT * total_area_covered + (s.graftCount * 3);
}


void addCap( inout state s, inout uint seed )
{   

    float r; 
    // iterate over indices until valid position is chosen
    uint index;
    do
    {
        r     = rand( seed ) * (PL_MAX_RADIUS-PL_MIN_RADIUS) + PL_MIN_RADIUS; 
        index = uint( uSiteGridSize*rand( seed ) );
    }
    while ( !isWithinOverlapThreshold( vec3( iSitePositions( index ) ), r*PL_OVERLAP_THRESHOLD ) );
    
    
    //if ( isWithinOverlapThreshold( vec3( iSitePositions( index ) ), r*PL_OVERLAP_THRESHOLD ) )
    //{
    
        s.positions[s.graftCount] = iSitePositions( index );
        s.normals  [s.graftCount] = iSiteNormals  ( index );
        s.radii    [s.graftCount] = r;   
        s.graftCount++;  
    //}
}


void removeCap( inout state s, in uint index )
{ 
    // shift all other elements down
    for (uint i=index; i<s.graftCount; i++)
    {
        if (i+1 == PL_MAX_GRAFTS_PER_SOLUTION)  // max sure doesnt go out of bounds
        {
            s.positions[i] = vec4(-1, -1, -1, -1);
            s.normals  [i] = vec4(-1, -1, -1, -1);
            s.radii    [i] = -1.0; 
        }    
        s.positions[i] = s.positions[i+1];
        s.normals  [i] = s.normals  [i+1];
        s.radii    [i] = s.radii    [i+1];                              
    }
    s.graftCount--;
}




void perturbState( inout state s, in uint seed )
{
    float PERTURBATION_SCALE = (4.0 * uStateTemperature) + 1.0; // at minimum perturbation will range 0-1
       
    for (uint i=0; i<s.graftCount; i++)
    {
        /*
        // get random rotation        
        float angle = ((rand( seed )*2.0)-1.0) * PERTURBATION_SCALE;
        float x = rand( seed );
        float y = rand( seed );
        float z = rand( seed );    
        vec3 axis = normalize( vec3( x, y, z ) );
        mat4 rot;   rotate( rot, angle, axis ); 
        */
        
        // get random translation
        float tx = rand( seed );
        float ty = rand( seed );
        float tz = rand( seed ); 

        vec3 projectedTrans = projectOntoPlane( vec3( tx, ty, tz ), vec3( s.normals[i] ) );
            
        vec3 trans = normalize(projectedTrans) * ( ((rand( seed )*2.0)-1.0) * PERTURBATION_SCALE);

        float newRadius = s.radii[i] * (1 + ( (rand( seed )*2.0)-1.0) * uStateTemperature);
            
        newRadius = clamp( newRadius, PL_MIN_RADIUS, PL_MAX_RADIUS);  
   
        if ( isValidPerturbation( vec3(s.positions[i]) + trans, newRadius*PL_OVERLAP_THRESHOLD ) )    
        {
            s.positions[i] = s.positions[i] + vec4(trans, 1.0);
            s.radii    [i] = newRadius;
        }
            
        //s.normals  [i] = vec4( normalize( mat3( rot[0], rot[1], rot[2]) * vec3(s.normals[i]) ), 1.0 );

    }
}


void copyGlobalState( inout state s )
{
    s.graftCount = uStateGraftCount;
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = uStateGraftPositions[i];
        s.normals  [i] = uStateGraftNormals  [i];
        s.radii    [i] = uStateGraftRadii    [i];
    }
    s.energy = uStateEnergy;
}


void main(void)
{ 
    // get global invocation id
    int gid = int( gl_GlobalInvocationID.x );  
      
    // get invocation unique seed value for RNG
    uint seed = uint( uSeed+gid );  
       
    // create local state and copy data from global state 
    state nS;  copyGlobalState( nS ); 
       
    // determine which case
    uint changeCase = gid % 3;
        
    if (changeCase == 0 || nS.graftCount == 0)
    {
        // add random
        if (nS.graftCount < PL_MAX_GRAFTS_PER_SOLUTION)
        {
            addCap( nS, seed ); //uint( uSiteGridSize*rand( seed ) ) );
        }
    }
    else if (changeCase == 1)
    {
        // remove random
        removeCap( nS, uint( nS.graftCount*rand( seed ) ) );
    }
   
    // peturb state
    perturbState( nS, seed );
    
    // calc energy
    nS.energy = energy( nS );    
   
    // store state energy
    stateEnergies[gid] = nS.energy;

    // store state graft count
    stateGraftCounts[gid] = nS.graftCount;

    // store state positions, normals, and radii  
    uint offset = gid*PL_MAX_GRAFTS_PER_SOLUTION;  
    for (int i=0; i<nS.graftCount; i++)
    {
        stateGraftPositions[offset+i] = nS.positions[i];
        stateGraftNormals  [offset+i] = nS.normals  [i]; 
        stateGraftRadii    [offset+i] = nS.radii    [i];   
    }

    
}


