#version 430

//#define PL_ITERATIONS               1
#define PL_MAX_GRAFTS_PER_SOLUTION  16
#define PL_MAX_RADIUS               4.0
#define PL_MIN_RADIUS               3.0
#define PL_OVERLAP_THRESHOLD        0.8

layout (local_size_x = 16) in;

// shader storage buffer objects
layout (std430,  binding = 0) buffer siteDataBlock        { vec4 siteData[]; };

// temporary buffer
layout (std430,  binding = 1) buffer tempBuffer           { float overlappedTriangles[]; };

// output buffers
layout (std430,  binding = 2) buffer StateEnergiesBlock   { float stateEnergies      []; };
layout (std430,  binding = 3) buffer StatePositionBlock   { vec4  stateGraftPositions[]; };
layout (std430,  binding = 4) buffer StateNormalBlock     { vec4  stateGraftNormals  []; };
layout (std430,  binding = 5) buffer StateRadiiBlock      { float stateGraftRadii    []; };
layout (std430,  binding = 6) buffer StateGraftCountBlock { uint  stateGraftCounts   []; };

// site uniforms
uniform uint  uSiteMeshSize;
uniform float uSiteMeshArea;
uniform uint  uSiteGridSize;
uniform uint  uSitePerimSize;

// current best state uniforms
uniform float uStateTemperature;
uniform float uStateEnergy;
uniform uint  uStateGraftCount;
uniform vec4  uStateGraftPositions [PL_MAX_GRAFTS_PER_SOLUTION];
uniform vec4  uStateGraftNormals   [PL_MAX_GRAFTS_PER_SOLUTION];
uniform float uStateGraftRadii     [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint uSeed;
uniform uint uLoadLocal;


struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct edge
{
    vec3 p0;
    vec3 p1;
    vec3 n;
};


struct state
{
    vec4  positions     [PL_MAX_GRAFTS_PER_SOLUTION];
    vec4  normals       [PL_MAX_GRAFTS_PER_SOLUTION];
    float radii         [PL_MAX_GRAFTS_PER_SOLUTION];
    uint  graftCount;
    float energy;
};


void setOverlap( in uint index, in float value )
{
    overlappedTriangles[gl_GlobalInvocationID.x*uSiteMeshSize + index] = value;
}


float getOverlap( in uint index )
{
    return overlappedTriangles[gl_GlobalInvocationID.x*uSiteMeshSize + index];
}


vec4 sitePositions( in uint i )
{
    return siteData[i];
}


vec4 siteNormals( in uint i )
{
    return siteData[uSiteGridSize+i];
}


triangle siteTriangles( in uint i )
{
    uint j = uSiteGridSize*2 + i*4;    
    triangle t;
    t.p0 = vec3( siteData[j+0] );
    t.p1 = vec3( siteData[j+1] );
    t.p2 = vec3( siteData[j+2] );
    t.n  = vec3( siteData[j+3] );
    return t;
}


edge siteEdge( in uint i )
{
    uint offset = uSiteGridSize*2 + uSiteMeshSize*4;
    uint j = offset + i;
    uint k = offset + ( (i+1) % uSitePerimSize );
    
    edge e;
    e.p0 = vec3( siteData[ j ] );
    e.p1 = vec3( siteData[ k ] );  
    e.n  = vec3( siteData[ j+uSitePerimSize ] );    
    return e;
}

vec3 projectOntoPlane( in vec3 point, in vec3 plane_normal )
{
    float dist = dot( point, plane_normal);    
    return point - (dist * plane_normal);
}

float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return distance( v, dot(v, axis)*axis );
}

vec3 closestPointOnSegment( in vec3 p, in edge e)
{
    vec3 ab = e.p1 - e.p0;
    float t = dot( (p - e.p0), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return e.p0 + t * ab;
}

bool isWithinOverlapThreshold( in vec3 pos, in float threshold )
{
    bool inside = true;
    for (int i=0; i<uSitePerimSize; i++)
    {
        edge e = siteEdge( i );
        if ( distance( pos, closestPointOnSegment( pos, e) ) < threshold )
        {
            inside = false;
        }        
    }    
    return inside;
}

bool isValidPerturbation( in vec3 pos, in float threshold )
{
    bool inside = true;
    for (int i=0; i<uSitePerimSize; i++)
    {
        edge e = siteEdge( i );
        if ( dot( pos-e.p0, e.n ) > 0.0 ||
             distance( pos, closestPointOnSegment( pos, e) ) < threshold)
        {
            inside = false;
        }        
    }    
    return inside;
}

uint randomize( inout uint seed )
{   
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}


bool intersectTriangle( in vec3 position, in vec3 normal, in triangle t, in float radius ) 
{
    if ( dot(t.n, normal) < 0 )
        return false;

    // get vector from graft centre to triangle point
    vec3 point0 = t.p0 - position;
    vec3 point1 = t.p1 - position;
    vec3 point2 = t.p2 - position;
    
    return ( distToAxis( normal, point0 ) < radius ||
             distToAxis( normal, point1 ) < radius ||
             distToAxis( normal, point2 ) < radius );
  
}


float area( in triangle t)
{
    return 0.5 * length( cross( (t.p1 - t.p0),  (t.p2 - t.p0) ) );
}


float area_uncovered( in state s )
{           
    float overlapped_area = 0;    
    // iterate over triangles, if they are in cap, value > 0, add to sum
    for (uint i = 0; i < uSiteMeshSize; i++)
    {        
         overlapped_area += getOverlap( i );   
         setOverlap( i, 0 );   
    }          
    return uSiteMeshArea - overlapped_area;
}


float calculateCap( in vec4 position, in vec4 normal, in float radius ) //in uint index, in mat4 perturbation )
{   
    float area_sum = 0;

    // iterate through each triangle in mesh
    for(uint i=0; i<uSiteMeshSize; i++)
    {
        // create triangle struct
        triangle t = siteTriangles( i );

        if ( intersectTriangle( vec3( position ), vec3( normal ),  t, radius ) )  
        {
            float t_area = area( t );
            area_sum += t_area;  
            setOverlap( i, t_area ); 
        }  
    }
    return area_sum;
}

void rotate( inout mat4 mat, in float angle, in vec3 axis ) 
{
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    // all angles in radians
    float s = sin( angle*0.017453292 );
    float c = cos( angle*0.017453292 );

    float mag = length( axis ); 

    // zero vector, return identity
    if (mag == 0.0) 
    {
        mat = mat4(1.0);
        return;
    }

    // Rotation matrix is normalized
    x /= mag;
    y /= mag;
    z /= mag;

    float xx, yy, zz, xy, yz, zx, xs, ys, zs, one_c;
    xx = x * x;
    yy = y * y;
    zz = z * z;
    xy = x * y;
    yz = y * z;
    zx = z * x;
    xs = x * s;
    ys = y * s;
    zs = z * s;
    one_c = 1.0f - c;

    mat = mat4(1.0);
    
    mat[0][0] = (one_c * xx) + c;
    mat[0][1] = (one_c * xy) - zs;
    mat[0][2] = (one_c * zx) + ys;

    mat[1][0] = (one_c * xy) + zs;
    mat[1][1] = (one_c * yy) + c;
    mat[1][2] = (one_c * yz) - xs;
    
    mat[2][0] = (one_c * zx) - ys;
    mat[2][1] = (one_c * yz) + xs;
    mat[2][2] = (one_c * zz) + c;
}


float energy ( in state s )
{
    float total_area_covered = 0;   // includes overlaps
    for (uint i=0; i<s.graftCount; i++)
    {
         // calculate cap returns area from the cap, and also flags any overlapped triangles
         total_area_covered += calculateCap( s.positions[i], s.normals[i], s.radii[i] ); 
    }

    // calculate energy
    float WEIGHT = 0.4;
    return area_uncovered( s ) + WEIGHT * total_area_covered;
}


void addCap( inout state s, inout uint seed )
{   
    /*
    float radius; 
    // iterate over indices until valid position is chosen
    uint index;
    do
    {
        radius = uint( rand( seed ) * (PL_MAX_RADIUS-PL_MIN_RADIUS+1) + PL_MIN_RADIUS); 
        index  = uint( uSiteGridSize*rand( seed ) );
    }
    while ( !isWithinOverlapThreshold( vec3( sitePositions( index ) ), radius*PL_OVERLAP_THRESHOLD ) );

    s.positions[s.graftCount] = sitePositions( index );
    s.normals  [s.graftCount] = siteNormals  ( index );
    s.radii    [s.graftCount] = radius;   
    s.graftCount++;  
    */
    
    float radius = uint( rand( seed ) * (PL_MAX_RADIUS-PL_MIN_RADIUS+1) + PL_MIN_RADIUS); 
    uint  index  = uint( uSiteGridSize*rand( seed ) );
    
    if ( isWithinOverlapThreshold( vec3( sitePositions( index ) ), radius*PL_OVERLAP_THRESHOLD ) )
    {    
        s.positions[s.graftCount] = sitePositions( index );
        s.normals  [s.graftCount] = siteNormals  ( index );
        s.radii    [s.graftCount] = radius;   
        s.graftCount++;  
    }
}


void removeCap( inout state s, inout uint seed )
{ 
    uint index = uint( s.graftCount*rand( seed ) );
    
    // shift all other elements down
    for (uint i=index; i<s.graftCount; i++)
    {
        if (i+1 == PL_MAX_GRAFTS_PER_SOLUTION)  // max sure doesnt go out of bounds
        {
            s.positions[i] = vec4(-1, -1, -1, -1);
            s.normals  [i] = vec4(-1, -1, -1, -1);
            s.radii    [i] = -1.0; 
        }    
        s.positions[i] = s.positions[i+1];
        s.normals  [i] = s.normals  [i+1];
        s.radii    [i] = s.radii    [i+1];                              
    }
    s.graftCount--;
}




void perturbState( inout state s, inout uint seed )
{
    float PERTURBATION_SCALE = uStateTemperature; //(2.0 * uStateTemperature) + 1.0; // at minimum perturbation will range 0 - 0.5   
             
    for (uint i=0; i<s.graftCount; i++)
    {
        /*
        // get random rotation        
        float angle = ((rand( seed )*2.0)-1.0) * PERTURBATION_SCALE;
        float x = rand( seed );
        float y = rand( seed );
        float z = rand( seed );    
        vec3 axis = normalize( vec3( x, y, z ) );
        mat4 rot;   rotate( rot, angle, axis ); 
        */
        
        /*
        vec3 trans;
        uint c = 0;
        do
        {
            // get random translation
            float tx = rand( seed );
            float ty = rand( seed );
            float tz = rand( seed ); 

            vec3 projectedTrans = projectOntoPlane( vec3( tx, ty, tz ), vec3( s.normals[i] ) );
                
            trans = normalize( projectedTrans ) * ( ((rand( seed )*2.0)-1.0) * PERTURBATION_SCALE);
            c++;
        }
        while ( !isValidPerturbation( vec3( s.positions[i] ) + trans, s.radii[i]*PL_OVERLAP_THRESHOLD ) && c < 3 );    
        
        s.positions[i] = s.positions[i] + vec4(trans, 1.0);
        */
        
        // get random translation
        float tx = rand( seed );
        float ty = rand( seed );
        float tz = rand( seed ); 

        vec3 projectedTrans = projectOntoPlane( vec3( tx, ty, tz ), vec3( s.normals[i] ) );           
        vec3 trans          = normalize( projectedTrans ) * ( ((rand( seed )*2.0)-1.0) * PERTURBATION_SCALE);

        if ( isValidPerturbation( vec3( s.positions[i] ) + trans, s.radii[i]*PL_OVERLAP_THRESHOLD ) )    
        {
            s.positions[i] = s.positions[i] + vec4(trans, 1.0);
        }
            
        //s.normals  [i] = vec4( normalize( mat3( rot[0], rot[1], rot[2]) * vec3(s.normals[i]) ), 1.0 );

    }
}


void copyState( inout state s, in state S )
{
    s.graftCount = S.graftCount;
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = S.positions[i];
        s.normals  [i] = S.normals  [i];
        s.radii    [i] = S.radii    [i];
    }
    s.energy = S.energy;
}


void copyGlobalState( inout state s )
{
    s.graftCount = uStateGraftCount;
    s.energy     = uStateEnergy;
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = uStateGraftPositions[i];
        s.normals  [i] = uStateGraftNormals  [i];
        s.radii    [i] = uStateGraftRadii    [i];
    } 
}


void copyLocalState( inout state s )
{
    uint offset = gl_GlobalInvocationID.x*PL_MAX_GRAFTS_PER_SOLUTION;  

    s.graftCount = stateGraftCounts[ gl_GlobalInvocationID.x ];
    s.energy     = stateEnergies   [ gl_GlobalInvocationID.x ];
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = stateGraftPositions[offset+i];
        s.normals  [i] = stateGraftNormals  [offset+i];
        s.radii    [i] = stateGraftRadii    [offset+i];
    }    
}


float acceptanceProbability( in float energy, in float newEnergy) 
{
    float result;
    // If the new solution is better, accept it
    if (newEnergy < energy) 
    {
        result = 1.0;
    }
    else
    {
        // If the new solution is worse, calculate an acceptance probability
        result = exp( -(newEnergy - energy) / uStateTemperature );
    }
    return result;
}

void main(void)
{ 
    // get global invocation id
    uint gid = gl_GlobalInvocationID.x;  
      
    // get invocation unique seed value for RNG
    uint seed = uint( uSeed*(gid+1) );  
            
    // acquire current state (whether global or local)  
    state S, nS;   
    if ( uLoadLocal == 1 )  
    { 
        copyLocalState( S  );
    }
    else   
    {
        copyGlobalState( S ); 
    }
    copyState( nS, S );
        
    // determine which case
    uint changeCase = uint( rand( seed ) * 3 );
        
    if (nS.graftCount == 0 || changeCase == 0)
    {
        // add random
        if (nS.graftCount < PL_MAX_GRAFTS_PER_SOLUTION)
        {
            addCap( nS, seed );
        }
    }
    else if (changeCase == 1)
    {
        // remove random
        removeCap( nS, seed );
    }
              
    // peturb state
    perturbState( nS, seed );
    
    // calc energy
    nS.energy = energy( nS );
                
    if ( acceptanceProbability( S.energy, nS.energy ) > rand( seed ) )
    {
        copyState( S, nS );            
    } 
    
    // store state energy
    stateEnergies[gid] = S.energy;

    // store state graft count
    stateGraftCounts[gid] = S.graftCount;

    // store state positions, normals, and radii  
    uint offset = gid*PL_MAX_GRAFTS_PER_SOLUTION;  
    for (int i=0; i<S.graftCount; i++)
    {
        stateGraftPositions[offset+i] = S.positions[i];
        stateGraftNormals  [offset+i] = S.normals  [i]; 
        stateGraftRadii    [offset+i] = S.radii    [i];   
    } 
   
    
    
    
}


