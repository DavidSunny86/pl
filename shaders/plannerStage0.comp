#version 430

#define PL_MAX_GRAFTS_PER_SOLUTION  20


layout (local_size_x = 1024) in;

// input textures
layout (rgba32f, binding = 0) uniform image1D iSiteData;
/*
layout (rgba32f, binding = 0) uniform image1D iSiteGridPositions;
layout (rgba32f, binding = 1) uniform image1D iSiteGridNormals;
layout (rgba32f, binding = 2) uniform image2D iSiteMeshTriangles;
*/

// temporary textures
layout (r32f,    binding = 3) uniform image2D tOverlappedTriangleAreas;

// output textures
layout (rg32f,    binding = 4) uniform image1D  oStateEnergies;
/*
layout (rgba32f, binding = 5) uniform image2D  oStateGraftPoints;
layout (rgba32f, binding = 6) uniform image2D  oStateGraftNormals;
layout (r32f,    binding = 7) uniform image2D  oStateGraftRadii;
*/

layout (r32ui,   binding = 5) uniform uimage2D oStateIndices;
layout (rgba32f, binding = 6) uniform image2D  oStatePerturbations;
layout (r32ui,   binding = 7) uniform uimage1D oStateGraftCounts;

// input uniforms
uniform uint  uSiteMeshSize;
uniform float uSiteMeshArea;
uniform uint  uSiteGridSize;

uniform float uStateTemperature;
uniform float uStateEnergy;
uniform uint  uStateGraftCount;
uniform mat4  uStatePerturbations [PL_MAX_GRAFTS_PER_SOLUTION];
uniform uint  uStateIndices       [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint uSeed;

struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct gridPoint
{
    vec3 p;
    vec3 n;
};


struct state
{
    uint  indices       [PL_MAX_GRAFTS_PER_SOLUTION];
    mat4  perturbations [PL_MAX_GRAFTS_PER_SOLUTION];
    uint  graftCount;
    float energy;
};



vec4 iSitePositions( in uint i )
{
    //return imageLoad( iSiteGridPositions, int(i) );
    return imageLoad( iSiteData, int(i) );
}

vec4 iSiteNormals( in uint i )
{
    //return imageLoad( iSiteGridNormals, int(i) );
    return imageLoad( iSiteData, int(uSiteGridSize) + int(i) );
}

triangle iSiteTriangles( in uint i )
{
    int j = int(uSiteGridSize)*2 + (int(i)*4);
    triangle t;
    /*
    t.p0 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,0) ) );
    t.p1 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,1) ) );
    t.p2 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,2) ) );
    t.n  = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,3) ) ); 
    */
    
    t.p0 = vec3( imageLoad( iSiteData, j+0 ) );
    t.p1 = vec3( imageLoad( iSiteData, j+1 ) );
    t.p2 = vec3( imageLoad( iSiteData, j+2 ) );
    t.n  = vec3( imageLoad( iSiteData, j+3 ) ); 
    
    return t;
}



vec3 projectOntoPlane( in vec3 point, in vec3 plane_normal )
{
    float dist = dot( point, plane_normal);
    
    return point - (dist * plane_normal);
}

float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return length(v - dot(v, axis)*axis);
}


vec3 pointOnCircumference( in vec3 u, in vec3 v, in float radius )
{
    float a = dot( (v-u), (v-u) );
    float b = 2 * dot( u, (v-u) );
    float c = dot( u, u ) - radius*radius;

    float radical = b*b - 4*a*c;
    
    if (radical < 0) 
    {
        // error
        return vec3(0,0,0);	
    }

    float root = sqrt(radical);

    float t1 = (-b + root)/(2*a);
    float t2 = (-b - root)/(2*a);

    float t;
    if (t1 >= 0 && t1 <= 1 && (t1 <= t2 || t2 <= 0))
    {
        t = t1;
    }
    else if (t2 >= 0 && t2 <= 1 && (t2 <= t1 || t1 >= 1))
    {
        t = t2;
    }
    else 
    {
        // error
        return vec3(0,0,0);	
    }

    return u + t*(v-u);
    
}


int intersectTriangle( out triangle tri[2], in gridPoint g, in triangle t, in float radius ) 
{
    if ( dot(t.n, g.n) < 0 )
        return 0;

    // get vector from graft centre to triangle point
    vec3 point0 = t.p0 - g.p;
    vec3 point1 = t.p1 - g.p;
    vec3 point2 = t.p2 - g.p;
    
    // Compute distance to graft axis
    float dist0 = distToAxis( g.n, point0 );
    float dist1 = distToAxis( g.n, point1 );
    float dist2 = distToAxis( g.n, point2 );
    
    // If too far from graft axis, reject.  Note that this will miss some slightly-overlapping triangles!
    float minDist = min( dist0, min( dist1, dist2 ) );
    
    if ( minDist > radius )
    {
        // no vertices are inside      
        return 0;
    }
    
    // calculate the projected distance on the axis (normal)  
    float proj0 = dot( point0, g.n );
    float proj1 = dot( point1, g.n );
    float proj2 = dot( point2, g.n );

    float maxProj = max( proj0, max( proj1, proj2 ) );
    float minProj = min( proj0, min( proj1, proj2 ) );
    
    float VERTICAL_THRESHOLD = 8.0f;
        
    if (minProj > VERTICAL_THRESHOLD || maxProj < -VERTICAL_THRESHOLD)
        return 0;   
    
    // If entirely within the graft, accept the whole triangle (this is cheaper).
    float maxDist = max( dist0, max( dist1, dist2 ) );

    if (maxDist <= radius) 
    {
        tri[0].p0 = t.p0;
        tri[0].p1 = t.p1;
        tri[0].p2 = t.p2; 
        tri[0].n  = t.n;
        return 1;
    }
    
    // Not entirely within the graft, so find the intersection of the
    // triangle with the cylinder wall

    // Find a first vertex that is inside

    vec3  vs[3];
    float ds[3];
  
    if (dist0 <= radius) 
    {
        vs[0] = t.p0; ds[0] = dist0;
        vs[1] = t.p1; ds[1] = dist1;
        vs[2] = t.p2; ds[2] = dist2;
    } 
    else if (dist1 <= radius)
    {
        vs[0] = t.p1; ds[0] = dist1;
        vs[1] = t.p2; ds[1] = dist2;
        vs[2] = t.p0; ds[2] = dist0;
    } 
    else 
    {    
        vs[0] = t.p2; ds[0] = dist2;
        vs[1] = t.p0; ds[1] = dist0;
        vs[2] = t.p1; ds[2] = dist1;
    }

    bool prevInside = true; // always starts as true (ds[0] <= radius)

    vec3 points[4];
    int count = 0;
    
    for (int i=0; i<3; i++) 
    {
        int j = (i+1) % 3;		// vertex at next end of edge

        bool nextInside = (ds[j] <= radius);

        if (prevInside && nextInside) 
        {
            // Add inside triangle point
            points[count++] = vs[j];
        } 
        else if (prevInside && !nextInside) 
        {
            // Find point on edge of graft
            points[count++] = pointOnCircumference( (vs[i]-g.p), (vs[j]-g.p), radius ) + g.p;
        } 
        else if (!prevInside && nextInside) 
        {
            // Find entering point and angle 
            points[count++] = pointOnCircumference( (vs[i]-g.p), (vs[j]-g.p), radius ) + g.p;
            // Add inside triangle point    
            points[count++] = vs[j];
        }

        prevInside = nextInside;
    }

    tri[0].p0 = points[0];
    tri[0].p1 = points[1];
    tri[0].p2 = points[2];
    tri[0].n = t.n;
    
    if (count == 4)
    {
        // polygons reach a max of 4 vertices, so if there are 4, create a second triangle
        tri[1].p0 = points[0];
        tri[1].p1 = points[2];
        tri[1].p2 = points[3];
        tri[1].n = t.n;
        return 2;
    }
    return 1;
}


float area( in triangle t)
{
    return 0.5 * length( cross( (t.p1 - t.p0),  (t.p2 - t.p0) ) );
}


float area_uncovered( in state s )
{       
    int gid = int( gl_GlobalInvocationID.x ); 
         
    float overlapped_area = 0;    
    // iterate over triangles, if they are in cap, value > 0, add to sum
    for (uint i = 0; i < uSiteMeshSize; i++)
    {  
         overlapped_area += imageLoad( tOverlappedTriangleAreas, ivec2(i, gid) ); 
    }      
    
    return uSiteMeshArea - overlapped_area;
}


float calculateCap( in uint index, in mat4 perturbation )
{   
    int gid = int( gl_GlobalInvocationID.x ); 

    float radius = 4.0;    

    vec3 position = vec3( perturbation * iSitePositions( index ) );     //imageLoad( iSiteGridPositions, int(index) ) );
    vec3 normal   = mat3(perturbation) * vec3( iSiteNormals( index ) ); //imageLoad( iSiteGridNormals,   int(index) ) );    
       
    gridPoint g;    
    g.p = position;
    g.n = normalize( normal );
    
    float area_sum = 0;

    // iterate through each triangle in mesh
    for(uint i=0; i<uSiteMeshSize; i++)
    {
        // create triangle struct
        triangle t = iSiteTriangles( i );
        /*
        t.p0 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,0) ) );
        t.p1 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,1) ) );
        t.p2 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,2) ) );
        t.n  = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,3) ) ); 
        */
        triangle tris[2];   // triangle(s) to be added to graft cap
        int num_results = intersectTriangle( tris, g, t, radius );  // num_results is the number of triangles returned, 0 <= t <= 2

        float tri_area = 0;

        for (uint j=0; j<num_results; j++)
        {
            // accumulate area
            tri_area += area( tris[j] );              
        }  
        
        area_sum += tri_area;
        
        // store overlapped triangle indices
        if (num_results > 0)
        {   
            // if partial area is > 50% full triangle area, flag as overlapped
            if ( tri_area > (area( t )*0.5) )            
                imageStore( tOverlappedTriangleAreas, ivec2( i, gid ), vec4( area(t), 0, 0, 0) );  
        }
                       
    }
    
    return area_sum;
}

void rotate( inout mat4 mat, in float angle, in vec3 axis ) 
{
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    // all angles in radians
    float s = sin( angle*0.017453292 );
    float c = cos( angle*0.017453292 );

    float mag = length( axis ); //sqrt(x*x + y*y + z*z);

    // zero vector, return identity
    if (mag == 0.0) 
    {
        mat = mat4(1.0);
        return;
    }

    // Rotation matrix is normalized
    x /= mag;
    y /= mag;
    z /= mag;

    float xx, yy, zz, xy, yz, zx, xs, ys, zs, one_c;
    xx = x * x;
    yy = y * y;
    zz = z * z;
    xy = x * y;
    yz = y * z;
    zx = z * x;
    xs = x * s;
    ys = y * s;
    zs = z * s;
    one_c = 1.0f - c;

    mat = mat4(1.0);
    
    mat[0][0] = (one_c * xx) + c;
    mat[0][1] = (one_c * xy) - zs;
    mat[0][2] = (one_c * zx) + ys;

    mat[1][0] = (one_c * xy) + zs;
    mat[1][1] = (one_c * yy) + c;
    mat[1][2] = (one_c * yz) - xs;
    
    mat[2][0] = (one_c * zx) - ys;
    mat[2][1] = (one_c * yz) + xs;
    mat[2][2] = (one_c * zz) + c;
}


float energy ( in state s )
{
    float total_area_covered = 0;   // includes overlaps
    for (uint i=0; i<s.graftCount; i++)
    {
         // calculate cap returns area from the cap, and also flags any overlapped triangles
         // in the temporary texture 'tOverlappedTriangleAreas'
         total_area_covered += calculateCap( s.indices[i], s.perturbations[i] ); //mat4(1.0) );
    }

    // calculate energy
    float WEIGHT = 0.4;
    return area_uncovered( s ) + WEIGHT * total_area_covered; // area_covered( s );
}


void addCap( inout state s, in uint index )
{    
    int gid = int( gl_GlobalInvocationID.x ); 
    s.perturbations[s.graftCount] = mat4( 1.0 ); //mat4(gid);    
    s.indices[s.graftCount]       = index;      
    s.graftCount++;    
}


void removeCap( inout state s, in uint index )
{ 
    // shift all other elements down
    for (uint i=index; i<s.graftCount; i++)
    {
        if (i+1 == PL_MAX_GRAFTS_PER_SOLUTION)  // max sure doesnt go out of bounds
        {
            s.indices[i] = 0;
            s.perturbations[i] = mat4(1.0);
        }                                 
        s.indices[i]       = s.indices[i+1];      
        s.perturbations[i] = s.perturbations[i+1];  
    }
    s.graftCount--;
}

uint randomize( inout uint seed )
{   
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    return seed;
}

float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}


void perturbState( inout state s, in uint seed )
{
    float PERTURBATION_SCALE = 5.0 * uStateTemperature;
       
    for (uint i=0; i<s.graftCount; i++)
    {
        // get random rotation        
        float angle = ((rand( seed )*2.0)-1.0) * PERTURBATION_SCALE;
        float x = rand( seed );
        float y = rand( seed );
        float z = rand( seed );    
        vec3 axis = normalize( vec3( x, y, z ) );
        mat4 rot;   rotate( rot, angle, axis ); 
        
        // get random translation
        float tx = rand( seed );
        float ty = rand( seed );
        float tz = rand( seed ); 

        vec3 projectedTrans = projectOntoPlane( vec3( x, y, z ), mat3(s.perturbations[i]) * vec3( iSiteNormals( i ) ) ); //imageLoad( iSiteGridNormals, int(i) ) ) );
            
        vec3 trans = normalize(projectedTrans) * ( ((rand( seed )*2.0)-1.0) * PERTURBATION_SCALE);
        
        s.perturbations[i] = s.perturbations[i] * mat4( rot[0], rot[1], rot[2], vec4( trans,1) ); //mat4( vec4(1,0,0,0), vec4(0,1,0,0), vec4(0,0,1,0), vec4(trans,1) );
    }
}


void copyGlobalState( inout state s )
{
    s.graftCount = uStateGraftCount;
    for (int i=0; i<s.graftCount; i++)
    {    
        s.indices[i]       = uStateIndices[i];        
        s.perturbations[i] = uStatePerturbations[i];
    }
    s.energy = uStateEnergy;
}


void main(void)
{ 
    // get global invocation id
    int gid = int( gl_GlobalInvocationID.x );  
      
    // get invocation unique seed value for RNG
    uint seed = uint( uSeed+gid );  
       
    // create local state and copy data from global state 
    state nS;  copyGlobalState( nS ); 
       
    // determine which case
    uint changeCase = gid % 3;
        
    if (changeCase == 0 || nS.graftCount == 0)
    {
        // add random
        if (nS.graftCount < PL_MAX_GRAFTS_PER_SOLUTION)
        {
            addCap( nS, uint( uSiteGridSize*rand( seed ) ) );
        }
    }
    else if (changeCase == 1)
    {
        // remove random
        removeCap( nS, uint( nS.graftCount*rand( seed ) ) );
    }
   
    // peturb state
    perturbState( nS, seed );
    
    // calc energy
    nS.energy = energy( nS );    
   
    // store state energy
    imageStore( oStateEnergies, gid, vec4( nS.energy, 0, 0, 0 ) );

    // store state graft count
    imageStore( oStateGraftCounts, gid, uvec4( nS.graftCount, 0, 0, 0 ) );

    // store state indices    
    for (int i=0; i<nS.graftCount; i++)
    {
        imageStore( oStateIndices, ivec2( i, gid ), uvec4( nS.indices[i], 0, 0, 0) );           
    }   
    
    // store state perturbations    
    for (int i=0; i<nS.graftCount; i++)
    {        
        imageStore( oStatePerturbations, ivec2( i*4+0, gid ), nS.perturbations[i][0] );           
        imageStore( oStatePerturbations, ivec2( i*4+1, gid ), nS.perturbations[i][1] );
        imageStore( oStatePerturbations, ivec2( i*4+2, gid ), nS.perturbations[i][2] );
        imageStore( oStatePerturbations, ivec2( i*4+3, gid ), nS.perturbations[i][3] );
        
        // vec4( uStateTemperature, uStateEnergy, uint( uSiteGridSize*rand( seed ) ) , uint( nS.graftCount*rand( seed ) ) ) ); //
    }

}


